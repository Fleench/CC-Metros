{
  mainFile = false,
  compressed = false,
  data = {
    [ "sys/apps/progdor2.lua" ] = "--[[\
	Progdor 2.0 - File Packaging\
	by LDDestroier\
	Get with:\
	 wget https://raw.githubusercontent.com/LDDestroier/CC/master/progdor2.lua\
\
	Uses CCA compression API, made by minizbot2012.\
--]]\
\
local progdor = {\
	version = \"2.0\",\
	PBlogPath = \".progdor_PB_uploads\",\
	channel = 8366,\
	skynetPath = \"skynet.lua\",\
	skynetURL = \"https://github.com/osmarks/skynet/raw/master/client.lua\"\
}\
\
local scr_x, scr_y = term.getSize()\
local modem = peripheral.find(\"modem\")\
local skynet, skynetBigReceive, skynetBigSend\
\
local function interpretArgs(tInput, tArgs)\
    local output = {}\
    local errors = {}\
    local usedEntries = {}\
    for aName, aType in pairs(tArgs) do\
        output[aName] = false\
        for i = 1, #tInput do\
            if not usedEntries[i] then\
                if tInput[i] == aName and not output[aName] then\
                    if aType then\
                        usedEntries[i] = true\
                        if type(tInput[i+1]) == aType or type(tonumber(tInput[i+1])) == aType then\
                            usedEntries[i+1] = true\
                            if aType == \"number\" then\
                                output[aName] = tonumber(tInput[i+1])\
                            else\
                                output[aName] = tInput[i+1]\
                            end\
                        else\
                            output[aName] = nil\
                            errors[1] = errors[1] and (errors[1] + 1) or 1\
                            errors[aName] = \"expected \" .. aType .. \", got \" .. type(tInput[i+1])\
                        end\
                    else\
                        usedEntries[i] = true\
                        output[aName] = true\
                    end\
                end\
            end\
        end\
    end\
    for i = 1, #tInput do\
        if not usedEntries[i] then\
            output[#output+1] = tInput[i]\
        end\
    end\
    return output, errors\
end\
\
local yield = function()\
	os.queueEvent(\"yield\")\
	os.pullEvent(\"yield\")\
end\
\
-- CCA API START --\
\
local bit = bit32\
local function pack(bn1, bn2)\
	return bit.band(bn1, 0xFF), bit.rshift(bn1, 8) + bit.lshift(bit.band(bn2, 0xF), 4), bit.rshift(bn2, 4)\
end\
local function upack(b1, b2, b3)\
	return (b1 + bit.lshift(bit.band(b2, 0xF), 8)), (bit.lshift(b3,4) + bit.band(bit.rshift(b2, 4), 0xF))\
end\
local function createDict(bool)\
	local ret = {}\
	for i = 1, 255 do\
		if bool then\
			ret[string.char(i)] = i\
		else\
			ret[i] = string.char(i)\
		end\
	end\
	if not bool then ret[256] = 256 end\
	return ret\
end\
local function cp(sInput)\
	local dic = createDict(true)\
	local s = \"\"\
	local ch\
	local dlen = 256\
	local result = {}\
	local temp\
	for i = 1, #sInput do\
		if dlen == 4095 then\
			result[#result + 1] = dic[s]\
			result[#result + 1] = 256\
			dic = createDict(true)\
			dlen = 256\
			s = \"\"\
		end\
		ch = sInput:sub(i, i)\
		temp = s..ch\
		if dic[temp] then\
			s = temp\
		else\
			result[#result + 1] = dic[s]\
			dlen = dlen	+1\
			dic[temp] = dlen\
			s = ch\
		end\
	end\
	result[#result + 1] = dic[s]\
\
	return result\
end\
local function dc(data)\
	local dic = createDict(false)\
	local entry\
	local ch\
	local currCode\
	local result = {}\
	result[#result + 1] = dic[data[1]]\
	prefix = dic[data[1]]\
	for i = 2, #data do\
		currCode = data[i]\
		if currCode == 256 then\
			dic = createDict(false)\
			prefix = \"\"\
		else\
			entry = dic[currCode]\
			if entry then -- exists in dictionary\
				ch = entry:sub(1, 1)\
				result[#result + 1] = entry\
				if prefix ~= \"\" then\
					dic[#dic+1] = prefix .. ch\
				end\
			else\
				ch = prefix:sub(1, 1)\
				result[#result + 1] = prefix..ch\
				dic[#dic + 1] = prefix..ch\
			end\
\
			prefix = dic[currCode]\
		end\
	end\
\
	return table.concat(result)\
end\
local function trim(inp)\
	for i = 0,2 do\
		if inp[#inp] == 0 then\
			inp[#inp] = nil\
		end\
	end\
end\
local function decompress(input)\
	local rec = {}\
	for i = 1, #input, 3 do\
		if i % 66 == 0 then\
			yield()\
		end\
		rec[#rec+1], rec[#rec+2] = upack(input[i], input[i+1] or 0, input[i+2] or 0)\
	end\
	trim(rec)\
	return dc(rec)\
end\
local function compress(input)\
	local rec = {}\
	local data = cp(input)\
	for i=1, #data, 2 do\
		yield()\
		rec[#rec+1], rec[#rec+2], rec[#rec+3] = pack(data[i], data[i+1] or 0)\
	end\
	trim(rec)\
	return rec\
end\
local function strCompress(input)\
	local output = {}\
	local tbl = compress(input)\
	for i = 1, #tbl do\
		output[i] = string.char(tbl[i])\
	end\
	return table.concat(output)\
end\
local function strDecompress(input)\
	local output = {}\
	for i = 1, #input do\
		output[i] = string.byte(input:sub(i,i))\
	end\
	return decompress(output)\
end\
-- CCA API END --\
\
-- colors that are always safe to set to\
local safeColorList = {\
	[colors.white] = true,\
	[colors.lightGray] = true,\
	[colors.gray] = true,\
	[colors.black] = true\
}\
\
-- pastebin uploads have a 512K limit\
local pastebinFileSizeLimit = 1024 * 512\
\
local argData = {\
	[\"-pb\"] = \"string\",		-- pastebin get\
	[\"-dd\"] = \"string\",		-- direct URL download\
	[\"-m\"] = \"string\",		-- specify main file\
	[\"-PB\"] = false,		-- pastebin upload\
	[\"-t\"] = false,			-- transmit file\
	[\"-r\"] = false,			-- receive file\
	[\"-R\"] = false,			-- include read-only files\
	[\"-P\"] = false,			-- include Progdor2 file\
	[\"-S\"] = false,			-- use skynet\
	[\"-e\"] = false,			-- automatic self-extractor\
	[\"-E\"] = \"string\",		-- specify output folder in self-extractor code\
	[\"-s\"] = false,			-- silent\
	[\"-a\"] = false,			-- use as API with require, also makes silent\
	[\"-c\"] = false,			-- use CCA compression\
	[\"-h\"] = false,			-- show help\
	[\"-i\"] = false,			-- inspect mode\
	[\"-o\"] = false,			-- always overwrite\
}\
\
local argList, argErrors = interpretArgs({...}, argData)\
\
if #argErrors > 0 then\
	local errList = \"\"\
	for k,v in pairs(argErrors) do\
		if k ~= 1 then\
			errList = errList .. \"\\\"\" .. k .. \"\\\": \" .. v .. \"; \"\
		end\
		error(errList:sub(1, -2))\
	end\
end\
\
local pastebinGet    		= argList[\"-pb\"] -- string, pastebin code\
local directDownload 		= argList[\"-dd\"] -- string, download URL\
local mainFile		 		= argList[\"-m\"]  -- string, main executable file\
local pastebinUpload 		= argList[\"-PB\"] -- boolean\
local selfExtractor	 		= argList[\"-e\"]  -- boolean\
local selfExtractorFolder 	= argList[\"-E\"]  -- string, folder output for self extractor code\
local silent		 		= argList[\"-s\"]  -- boolean\
local useCompression 		= argList[\"-c\"]  -- boolean\
local justOverwrite	 		= argList[\"-o\"]  -- boolean\
local allowReadOnly  		= argList[\"-R\"]  -- boolean\
local allowPackPD	 		= argList[\"-P\"]  -- boolean\
local useSkynet		 		= argList[\"-S\"]  -- boolean\
local trMode		 		= argList[\"-t\"] and \"transmit\" or (argList[\"-r\"] and \"receive\" or \"normal\")\
\
local skynet\
\
if useCompression and selfExtract then\
	error(\"Cannot use compression with self-extractor.\")\
end\
\
local sWrite = function(text)\
	if not silent then\
		return write(text)\
	end\
end\
\
local sPrint = function(text)\
	if not silent then\
		return print(text)\
	end\
end\
\
local cWrite = function(text, color, ignoreSilent)\
	local col = term.getTextColor()\
	term.setTextColor(color or col)\
	if ignoreSilent then\
		write(text)\
	else\
		sWrite(text)\
	end\
	term.setTextColor(col)\
end\
\
local cPrint = function(text, color, ignoreSilent)\
	local col = term.getTextColor()\
	term.setTextColor(color or col)\
	if ignoreSilent then\
		print(text)\
	else\
		sPrint(text)\
	end\
	term.setTextColor(col)\
end\
\
local function showHelp(verboseHelp)\
	local helpInfo\
	if verboseHelp then\
		helpInfo = {\
			\"Progdor v\" .. progdor.version,\
			\" -pb [pastebin ID] : Download from Pastebin.\",			-- added\
			\" -PB : Upload to pastebin.\",							-- added\
			\" -dd [download URL] : Download from URL.\",				-- added\
			\" -e : Adds on self-extractor code to archive.\",		-- added\
			\" -E [folder] : Extractor extracts to folder\",			-- added\
			\" -s : Silences all terminal writing\",					-- added\
			\" -S : Use skynet when transmitting/receiving.\",		-- added\
			\" -t : Transmit a folder/file.\",						-- added\
			\" -r : Receive a file/packed folder.\",					-- added\
			\" -R : Allow packing read-only files/folders.\",			-- added\
			\" -P : Allow packing in Progdor2 itself.\",				-- added\
			\" -a : Allows programs to use require() on Progdor.\",	-- added\
			\" -c : Enables CCA compression.\",						-- added\
			\" -m : Specify main executable file in archive.\",		-- added\
			\" -i : Inspect archive without extracting.\",			-- added\
			\" -o : Overwrite files without asking.\",				-- added\
		}\
	else\
		helpInfo = {\
			\"Progdor v\" .. progdor.version,\
			\"Usage: progdor [options] inputFolder (outputFile)\",\
			\"       progdor [options] inputFile (outputFolder)\",\
			\"\",\
			\"Progdor is a file/folder packaging program with support for CCA compression and self-extraction.\",\
			\"  If tacking on auto-extractor, a third argument will be the default extraction path.\",\
			\"\",\
			\"Use -h for all options.\",\
			\"\",\
			\"   This Progdor has Super Cow Powers.\"					-- not actually added\
		}\
	end\
	for y = 1, #helpInfo do\
		sPrint(helpInfo[y])\
	end\
end\
\
local setTextColor = function(color)\
	if (not silent) and (term.isColor() or safeColorList[color]) then\
		term.setTextColor(color)\
	end\
end\
\
local setBackgroundColor = function(color)\
	if (not silent) and (term.isColor() or safeColorList[color]) then\
		term.setBackgroundColor(color)\
	end\
end\
\
local inputPath = argList[1]\
local outputPath = argList[2] or inputPath\
local defaultAutoExtractPath = argList[3]\
local exists, mode\
\
if inputPath == \"moo\" and not fs.exists(inputPath) then\
	print([[\
                     \\_/\
   m00h  (__)       -(_)-\
      \\  ~Oo~___     / \\\
         (..)  |\\\
___________|_|_|_____________\
...\"Have you mooed today?\"...\"]])\
	return\
end\
\
if argList[\"-h\"] then\
	return showHelp(true)\
elseif argList[\"-a\"] or (not shell) then\
	mode = \"api\"\
elseif inputPath then\
	exists = fs.exists(inputPath)\
	if argList[\"-i\"] then\
		mode = \"inspect\"\
	elseif fs.isDir(inputPath) then\
		mode = \"pack\"\
	else\
		mode = \"unpack\"\
	end\
elseif trMode ~= \"receive\" then\
	return showHelp(false)\
end\
\
if mode == \"api\" then\
	silent = true\
elseif (pastebinGet or directDownload) and pastebinUpload then\
	error(\"Cannot upload and download at the same time!\")\
end\
\
local specialWrite = function(left, colored, right, color)\
	local origTextColor = term.getTextColor()\
	sWrite(left)\
	setTextColor(color)\
	sWrite(colored)\
	setTextColor(origTextColor)\
	sWrite(right)\
end\
\
local specialPrint = function(left, colored, right, color)\
	return specialWrite(left, colored, right .. \"\\n\", color)\
end\
\
local function listAll(path, includePath)\
	local output = {}\
	local list = fs.list(path)\
	local fc = fs.combine\
	for i = 1, #list do\
		if allowReadOnly or (not fs.isReadOnly(fc(path, list[i]))) then\
			if allowPackPD or fc(path, list[i]) ~= (shell and shell.getRunningProgram()) then\
				if fs.isDir(fc(path, list[i])) then\
					if #fs.list(fc(path, list[i])) == 0 then\
						output[#output+1] = (includePath and fc(path, list[i]) or list[i]) .. \"/\"\
					else\
						local la = listAll(fc(path, list[i]))\
						for ii = 1, #la do\
							output[#output+1] = includePath and fc(path, fc(list[i], la[ii])) or fc(list[i], la[ii])\
						end\
					end\
				else\
					output[#output+1] = includePath and fc(path, list[i]) or list[i]\
				end\
			end\
		end\
	end\
	return output\
end\
\
local makeFileList = function(path, doCompress)\
	local output = {}\
	local list = listAll(path, false)\
	local file\
	if not allowPackPD then\
		cPrint(\"Ignoring Progdor2.\", colors.lightGray)\
	end\
	if not allowReadOnly then\
		cPrint(\"Ignoring read-only files.\", colors.lightGray)\
	end\
	sPrint(\"Packing files...\")\
	for i = 1, #list do\
		setTextColor(colors.lightGray)\
		sWrite(\"'\" .. list[i] .. \"'...\")\
		if list[i]:sub(-1,-1) == \"/\" then\
			output[list[i]] = true -- indicates empty directory\
		else\
			file = fs.open(fs.combine(path, list[i]), \"r\")\
			output[list[i]] = doCompress and strCompress(file.readAll()) or file.readAll()\
			file.close()\
			setTextColor(colors.green)\
			sPrint(\"good\")\
		end\
	end\
	setTextColor(colors.white)\
	return output\
end\
\
local buildArchive = function(path, mainFile, doCompress)\
	local output = {\
		compressed = doCompress, -- uses CCA compression\
		mainFile = mainFile, -- specifies the main program within the archive to run, should I implement something to use that\
		data = makeFileList(path, doCompress) -- files and folders and whatnot\
	}\
	return textutils.serialize(output)\
end\
\
local parseArchiveData = function(input, doNotDecompress)\
	local archive = textutils.unserialize(input)\
	if archive then\
		if archive.compressed and (not doNotDecompress) then\
			for name, contents in pairs(archive.data) do\
				archive.data[name] = strDecompress(contents)\
			end\
			archive.compressed = false\
		end\
		return archive\
	else\
		return false\
	end\
end\
\
local parseArchive = function(path, doNotDecompress)\
	local file = fs.open(path, \"r\")\
	local output = parseArchiveData(file.readAll(), doNotDecompress)\
	file.close()\
	return output\
end\
\
local round = function(number, places)\
	return math.floor(number * (10^places)) / (10^places)\
end\
\
local choice = function(input,verbose)\
	if not input then\
		input = \"yn\"\
	end\
	if verbose then\
		sWrite(\"[\")\
		for a = 1, #input do\
			sWrite(input:sub(a,a):upper())\
			if a < #input then\
				sWrite(\",\")\
			end\
		end\
		sWrite(\"]?\")\
	end\
	local evt,char\
	repeat\
		evt,char = os.pullEvent(\"char\")\
	until string.find(input:lower(),char:lower())\
	if verbose then\
		sPrint(char:upper())\
	end\
	local pos = string.find(input:lower(), char:lower())\
	return pos, char:lower()\
end\
\
local overwriteOutputPath = function(inputPath, outputPath, allowMerge, override)\
	setTextColor(colors.white)\
	local c\
	if override then\
		return true, true\
	else\
		if allowMerge then\
			write(\"Overwrite [Y/N]? Or [M]erge? \")\
			c = choice(\"ynm\", false)\
		else\
			write(\"Overwrite [Y/N]?\")\
			c = choice(\"yn\", false)\
		end\
		write(\"\\n\")\
		if c == 1 then\
			return true, true\
		elseif c == 2 then\
			sPrint(\"Abort.\")\
			return false, false\
		elseif c == 3 then\
			return true, false\
		end\
	end\
end\
\
local uploadToPastebin = function(archive, name)\
	if #archive > pastebinFileSizeLimit then\
		error(\"That archive is too large to be uploaded to Pastebin. (limit is 512 KB)\")\
		return false\
	else\
		local key = \"0ec2eb25b6166c0c27a394ae118ad829\"\
		local response = http.post(\
			\"https://pastebin.com/api/api_post.php\",\
			\"api_option=paste&\" ..\
			\"api_dev_key=\" .. key .. \"&\" ..\
			\"api_paste_format=lua&\" ..\
			\"api_paste_name=\" .. textutils.urlEncode(name) .. \"&\" ..\
			\"api_paste_code=\" .. textutils.urlEncode(archive)\
		)\
		if response then\
			local sResponse = response.readAll()\
			response.close()\
\
			local sCode = string.match( sResponse, \"[^/]+$\" )\
			return sCode, sResponse\
		else\
			return false\
		end\
	end\
end\
\
local writeArchiveData = function(archive, outputPath)\
	local file\
	for name, contents in pairs(archive.data) do\
		setTextColor(colors.lightGray)\
		sWrite(\"'\" .. name .. \"'...\")\
		if contents == true then -- indicates empty directory\
			fs.makeDir(fs.combine(outputPath, name))\
		else\
			file = fs.open(fs.combine(outputPath, name), \"w\")\
			if file then\
				file.write(contents)\
				file.close()\
			end\
		end\
		if file then\
			setTextColor(colors.green)\
			sPrint(\"good\")\
		else\
			setTextColor(colors.red)\
			sPrint(\"fail\")\
		end\
	end\
	setTextColor(colors.white)\
	specialPrint(\"Unpacked to '\", outputPath .. \"/\", \"'.\", colors.yellow)\
end\
\
local getSkynet = function()\
	if http.websocket then\
		-- Skynet only supports messages that are 65506 bytes or smaller\
		-- I'm just going with 65200 bytes to play safe.\
		local defineBigOnes = function(skynet)\
			local div = 65200\
			return function(channel, _message)	-- big send\
				local message = textutils.serialize(_message)\
				for i = 1, math.ceil(#message / div) do\
					skynet.send(progdor.channel, {\
						msg = message:sub( (i - 1) * div + 1, i * div ),\
						complete = i == math.ceil(#message / div),\
						part = i\
					})\
					sleep(0.1)\
					cWrite(\".\", colors.lightGray)\
				end\
			end, function(channel)				-- big receive\
				local ch, msg\
				local output = {}\
				local gotFile = false\
				while true do\
					ch, msg = skynet.receive(channel)\
					if type(msg) == \"table\" then\
						if type(msg.complete) == \"boolean\" and type(msg.msg) == \"string\" and type(msg.part) == \"number\" then\
							output[msg.part] = msg.msg\
							cWrite(\".\", colors.lightGray)\
							if msg.complete then\
								break\
							end\
						end\
					end\
				end\
				return channel, textutils.unserialize(table.concat(output))\
			end\
		end\
		if skynet then\
			local bS, bR = defineBigOnes(skynet)\
			skynet.open(progdor.channel)\
			return skynet, \"\", bS, bR\
		else\
			if fs.exists(progdor.skynetPath) then\
				local sn = dofile(progdor.skynetPath)\
				sn.open(progdor.channel)\
				local bS, bR = defineBigOnes(sn)\
				return sn, \"\", bS, bR\
			else\
				local net, contents = http.get(progdor.skynetURL)\
				if net then\
					contents = net.readAll()\
					local file = fs.open(progdor.skynetPath, \"w\")\
					file.write(contents)\
					file.close()\
					local sn = dofile(progdor.skynetPath)\
					local bS, bR = defineBigOnes(sn)\
					sn.open(progdor.channel)\
					return sn, \"\", bS, bR\
				else\
					return false, \"Couldn't download Skynet.\"\
				end\
			end\
		end\
	else\
		return false, \"This version of CC does not support Skynet.\"\
	end\
end\
\
local getModem = function()\
	local mod = peripheral.find(\"modem\")\
	if mod then\
		mod.open(progdor.channel)\
		return mod\
	else\
		return false, \"No modem was found.\"\
	end\
end\
\
local archive\
local doOverwrite, doContinue = false, true\
\
--[[ JUST SUMMIN' UP THE ELSEIF CHAIN\
	if mode == \"api\" then\
	elseif trMode == \"transmit\" then\
		if mode == \"pack\" then\
		end\
	elseif trMode == \"receive\" then\
		if mode == \"pack\" then\
		end\
	elseif mode == \"pack\" then\
	elseif mode == \"unpack\" then\
	elseif mode == \"inspect\" then\
	end\
--]]\
\
-- API mode takes top priority\
if mode == \"api\" then\
\
	return {\
		parseArchive = parseArchive,\
		parseArchiveData = parseArchiveData,\
		buildArchive = buildArchive,\
		uploadToPastebin = uploadToPastebin,\
	}\
\
-- after that, trans\
elseif trMode == \"transmit\" then\
\
	-- assemble something to send\
	local output = {name = fs.getName(inputPath)}\
	if mode == \"pack\" then\
		output.contents = textutils.serialize(buildArchive(inputPath, mainFile, useCompression))\
	else\
		local file = fs.open(inputPath, \"r\")\
		output.contents = file.readAll()\
		file.close()\
	end\
\
	local grr\
	if useSkynet then\
		if not skynet then\
			cWrite(\"Connecting to Skynet...\", colors.lightGray)\
			skynet, grr, skynetBigSend, skynetBigReceive = getSkynet()\
			if not skynet then\
				print(grr)\
				print(\"Aborting.\")\
				return false\
			else\
				cPrint(\"good\", colors.green)\
			end\
		end\
		cWrite(\"Sending file...\", colors.lightGray)\
		skynetBigSend(progdor.channel, output)\
		skynet.socket.close()\
		cPrint(\"good\", colors.green)\
		sWrite(\"Sent '\")\
		cWrite(fs.getName(inputPath), colors.yellow)\
		sPrint(\"' using Skynet.\")\
	else\
		modem, grr = getModem()\
		if not modem then\
			print(grr)\
			print(\"Abort.\")\
			return false\
		end\
		cWrite(\"Sending file...\", colors.lightGray)\
		modem.transmit(progdor.channel, progdor.channel, output)\
		cPrint(\"good\", colors.green)\
		sWrite(\"Sent '\")\
		cWrite(fs.getName(inputPath), colors.yellow)\
		sPrint(\"' using modem.\")\
	end\
\
elseif trMode == \"receive\" then\
	local grr\
	local gotFile = false\
	local input, channel\
	local didAbort = false\
	if useSkynet then\
		if not skynet then\
			cWrite(\"Connecting to Skynet...\", colors.lightGray)\
			skynet, grr, skynetBigSend, skynetBigReceive = getSkynet()\
			if not skynet then\
				print(grr)\
				print(\"Aborting.\")\
				return false\
			else\
				cPrint(\"good\", colors.green)\
			end\
		end\
		cWrite(\"Waiting for file on Skynet...\", colors.lightGray)\
		local result, grr = pcall(function()\
			sleep(0.05)\
			while true do\
				if parallel.waitForAny(function()\
					channel, input = skynetBigReceive(progdor.channel)\
				end, function()\
					local evt\
					while true do\
						evt = {os.pullEvent()}\
						if evt[1] == \"key\" then\
							if evt[2] == keys.q then\
								return\
							end\
						end\
					end\
				end) == 2 then\
					print(\"\\nAbort.\")\
					sleep(0.05)\
					didAbort = true\
					break\
				end\
				if channel == progdor.channel and type(input) == \"table\" then\
					if type(input.contents) == \"string\" and type(input.name) == \"string\" then\
						gotFile = true\
						break\
					end\
				end\
			end\
		end)\
		skynet.socket.close()\
		if not result then\
			error(grr, 0)\
		end\
	else\
		modem, grr = getModem()\
		if not modem then\
			print(grr)\
			print(\"Abort.\")\
			sleep(0.05)\
			return false\
		end\
		modem.open(progdor.channel)\
		local evt\
		cWrite(\"Waiting for file...\", colors.lightGray)\
		sleep(0.05)\
		while true do\
			evt = {os.pullEvent()}\
			if evt[1] == \"modem_message\" then\
				if evt[3] == progdor.channel and type(evt[5]) == \"table\" then\
					if type(evt[5].contents) == \"string\" and type(evt[5].name) == \"string\" then\
						input = evt[5]\
						gotFile = true\
						break\
					end\
				end\
			elseif evt[1] == \"key\" then\
				if evt[2] == keys.q then\
					print(\"\\nAbort.\")\
					sleep(0.05)\
					didAbort = true\
					break\
				end\
			end\
		end\
	end\
\
	if gotFile then\
		cPrint(\"good\", colors.green)\
		if input.contents then\
			local writePath, c = fs.combine(shell.dir(), outputPath or input.name)\
			write(\"Received '\")\
			cWrite(input.name or outputPath, colors.yellow, true)\
			print(\"'.\")\
			if (not justOverwrite and fs.exists(writePath)) or fs.isReadOnly(writePath) then\
				write(\"\\nBut, '\")\
				cWrite(fs.getName(writePath), colors.yellow, true)\
				print(\"' is already there.\")\
				local roCount = 0\
				local showROmessage = function(roCount)\
					if roCount == 1 then\
						write(\"\\nThat file/folder is \")\
						cWrite(\"read-only\", colors.yellow, true)\
						print(\"!\")\
					elseif roCount == 2 then\
						write(\"\\nI told you, that file/folder is \")\
						cWrite(\"read-only\", colors.yellow, true)\
						print(\"!\")\
					elseif roCount == 3 then\
						write(\"\\nNope. The file/folder is \")\
						cWrite(\"read-only\", colors.yellow, true)\
						print(\".\")\
					elseif roCount == 4 then\
						write(\"\\nDoes the phrase \")\
						cWrite(\"read-only\", colors.yellow, true)\
						print(\" mean nothing to you?\")\
					elseif roCount == 5 then\
						print(\"\\nAlright wise-ass, that's enough.\")\
					elseif roCount > 5 then\
						write(\"\\nThat's \")\
						cWrite(\"read-only\", colors.yellow, true)\
						print(\", damn you!\")\
					end\
				end\
				while true do\
					sleep(0.05)\
					if roCount < 5 then\
						write(\"Overwrite [Y/N]? Or [R]ename?\\n\")\
						c = choice(\"nry\", false)\
					else\
						write(\"Overwrite [ /N]? Or [R]ename?\\n\")\
						c = choice(\"nr\", false)\
					end\
					if c == 3 then\
						if fs.isReadOnly(writePath) then\
							roCount = roCount + 1\
							showROmessage(roCount)\
						else\
							break\
						end\
					elseif c == 1 then\
						print(\"Abort.\")\
						return false\
					elseif c == 2 then\
						print(\"New name:\")\
						if shell.dir() == \"\" then\
							write(\"/\")\
						else\
							write(\"/\" .. shell.dir() .. \"/\")\
						end\
						writePath = fs.combine(shell.dir(), read())\
						roCount = roCount + 1\
						if fs.isReadOnly(writePath) then\
							showROmessage(roCount)\
						else\
							break\
						end\
					end\
				end\
			end\
			local file = fs.open(writePath, \"w\")\
			file.write(input.contents)\
			file.close()\
			sWrite(\"Wrote to '\")\
			cWrite(writePath, colors.yellow)\
			sPrint(\"'\")\
		end\
	elseif not didAbort then\
		print(\"fail!\")\
	end\
\
elseif mode == \"pack\" then\
\
	if not pastebinUpload then\
		if fs.isReadOnly(outputPath) then\
			error(\"Output path is read-only.\")\
		elseif fs.exists(outputPath) and (outputPath ~= inputPath) then\
			doContinue, doOverwrite = overwriteOutputPath(inputPath, outputPath, false, justOverwrite)\
		elseif fs.combine(\"\", outputPath) == \"\" then\
			error(\"Output path cannot be root.\")\
		end\
		if not doContinue then\
			return false\
		elseif outputPath == inputPath then\
			doOverwrite = true\
		end\
	end\
	archive = buildArchive(inputPath, mainFile, useCompression)\
	if exists then\
		if useCompression then\
			sPrint(\"Using CCA compression.\")\
		elseif selfExtractor then\
			sPrint(\"Tacking on self-extractor.\")\
			archive = ([[\
local tArg = {...}\
local selfDelete = false -- if true, deletes extractor after running\
local file\
local outputPath = ]] ..\
\
(selfExtractorFolder and (\
	\"shell.resolve(\\\"\" .. selfExtractorFolder .. \"\\\")\"\
) or (\
	\"tArg[1] and shell.resolve(tArg[1]) or \" .. ((defaultAutoExtractPath and (\"\\\"\" .. defaultAutoExtractPath .. \"\\\"\")) or \"shell.getRunningProgram()\")\
)) .. [[\
\
local safeColorList = {[colors.white] = true,[colors.lightGray] = true,[colors.gray] = true,[colors.black] = true}\
local stc = function(color) if (term.isColor() or safeColorList[color]) then term.setTextColor(color) end end\
local choice = function()\
	local input = \"yn\"\
	write(\"[\")\
	for a = 1, #input do\
		write(input:sub(a,a):upper())\
		if a < #input then\
			write(\",\")\
		end\
	end\
	print(\"]?\")\
	local evt,char\
	repeat\
		evt,char = os.pullEvent(\"char\")\
	until string.find(input:lower(),char:lower())\
	if verbose then\
		print(char:upper())\
	end\
	local pos = string.find(input:lower(), char:lower())\
	return pos, char:lower()\
end\
local archive = textutils.unserialize(]] ..\
\
textutils.serialize(archive) ..\
\
[[)\
if fs.isReadOnly(outputPath) then\
	error(\"Output path is read-only. Abort.\")\
elseif fs.getFreeSpace(outputPath) <= #archive then\
	error(\"Insufficient space. Abort.\")\
end\
\
]] .. ( justOverwrite and [[\
if fs.exists(outputPath) and fs.combine(\"\", outputPath) ~= \"\" then\
	fs.delete(outputPath)\
end\
]] or [[\
if fs.exists(outputPath) and fs.combine(\"\", outputPath) ~= \"\" then\
	print(\"File/folder already exists! Overwrite?\")\
	stc(colors.lightGray)\
	print(\"(Use -o when making the extractor to always overwrite.)\")\
	stc(colors.white)\
	if choice() ~= 1 then\
		error(\"Chose not to overwrite. Abort.\")\
	else\
		fs.delete(outputPath)\
	end\
end\
]]\
) ..\
[[\
if selfDelete or (fs.combine(\"\", outputPath) == shell.getRunningProgram()) then\
	fs.delete(shell.getRunningProgram())\
end\
for name, contents in pairs(archive.data) do\
	stc(colors.lightGray)\
	write(\"'\" .. name .. \"'...\")\
	if contents == true then -- indicates empty directory\
		fs.makeDir(fs.combine(outputPath, name))\
	else\
		file = fs.open(fs.combine(outputPath, name), \"w\")\
		if file then\
			file.write(contents)\
			file.close()\
		end\
	end\
	if file then\
		stc(colors.green)\
		print(\"good\")\
	else\
		stc(colors.red)\
		print(\"fail\")\
	end\
end\
stc(colors.white)\
write(\"Unpacked to '\")\
stc(colors.yellow)\
write(outputPath .. \"/\")\
stc(colors.white)\
print(\"'.\")\
]])\
\
		end\
		if pastebinUpload then\
			sWrite(\"Uploading to Pastebin...\")\
			local id, url = uploadToPastebin(archive, fs.getName(inputPath))\
			if id then\
				setTextColor(colors.green)\
				sPrint(\"success!\")\
				setTextColor(colors.white)\
				sPrint(\"Uploaded to '\" .. url .. \"'.\")\
				specialPrint(\"Retrieve with \\\"\", \"progdor -pb \" .. id .. \" \" .. fs.getName(inputPath), \"\\\".\", colors.yellow)\
				sPrint(\"You may need to do a Captcha on the website.\")\
				if not fs.exists(progdor.PBlogPath) then\
					setTextColor(colors.lightGray)\
					specialPrint(\"(PB uploads are logged at \\\"\", progdor.PBlogPath, \"\\\".)\", colors.yellow)\
					setTextColor(colors.white)\
				end\
				-- precautionary log file\
				local file = fs.open(progdor.PBlogPath, \"a\")\
				file.writeLine(\"uploaded \\\"\" .. inputPath .. \"\\\" to \\\"\" .. url .. \"\\\"\")\
				file.close()\
			else\
				sPrint(\"failed!\")\
			end\
		else\
			if doOverwrite then\
				fs.delete(outputPath)\
			end\
			local file = fs.open(outputPath, \"w\")\
			file.write(archive)\
			file.close()\
			if selfExtract then\
				specialPrint(\"Written self-extractor to '\", outputPath, \"'.\", colors.yellow)\
			else\
				specialPrint(\"Written to '\", outputPath, \"'.\", colors.yellow)\
			end\
		end\
	else\
		error(\"No such input path exists.\")\
		return false\
	end\
\
elseif mode == \"unpack\" then -- unpack OR upload\
\
	if pastebinUpload then\
		local file = fs.open(inputPath, \"r\")\
		archive = file.readAll()\
		file.close()\
		sWrite(\"Uploading to Pastebin...\")\
		local id, url = uploadToPastebin(archive, fs.getName(inputPath))\
		if id then\
			setTextColor(colors.green)\
			sPrint(\"success!\")\
			setTextColor(colors.white)\
			sPrint(\"Uploaded to '\" .. url .. \"'.\")\
			specialPrint(\"Retrieve with \\\"\", \"progdor -pb \" .. id .. \" \" .. fs.getName(inputPath), \"\\\".\", colors.yellow)\
			sPrint(\"You may need to do a Captcha on the website.\")\
			if not fs.exists(progdor.PBlogPath) then\
				setTextColor(colors.lightGray)\
				specialPrint(\"(PB uploads are logged at \\\"\", progdor.PBlogPath, \"\\\".)\", colors.yellow)\
				setTextColor(colors.white)\
			end\
			-- precautionary log file\
			local file = fs.open(progdor.PBlogPath, \"a\")\
			file.writeLine(\"uploaded \\\"\" .. inputPath .. \"\\\" to \\\"\" .. url .. \"\\\"\")\
			file.close()\
		else\
			setTextColor(colors.red)\
			sPrint(\"failed!\")\
			setTextColor(colors.white)\
			return false\
		end\
	elseif pastebinGet or directDownload then\
		local url, contents\
		if pastebinGet and directDownload then\
			error(\"Cannot do both pastebin get and direct download.\")\
		elseif fs.isReadOnly(outputPath) then\
			error(\"Output path is read-only.\")\
		elseif fs.combine(outputPath, \"\") == \"\" then\
			error(\"Output path cannot be root.\")\
		else\
			if pastebinGet then\
				url = \"http://www.pastebin.com/raw/\" .. pastebinGet\
			elseif directDownload then\
				url = directDownload\
			end\
			if fs.exists(outputPath) and (outputPath ~= inputPath) or outputPath == shell.getRunningProgram() then\
				doContinue, doOverwrite = overwriteOutputPath(inputPath, outputPath, true, justOverwrite)\
			end\
			if not doContinue then\
				return false\
			elseif outputPath == inputPath then\
				doOverwrite = true\
			end\
			sWrite(\"Connecting to \\\"\")\
			setTextColor(colors.yellow)\
			sWrite(url)\
			setTextColor(colors.white)\
			sWrite(\"\\\"...\")\
			local handle = http.get(url)\
			if handle then\
				cPrint(\"success!\", colors.green)\
				contents = handle.readAll()\
				handle.close()\
\
				-- detects if you didn't solve the captcha, since archives commonly trigger anti-spam measures\
				if (\
					pastebinGet and\
					(not textutils.unserialize(contents)) and\
					contents:find(\"Your paste has triggered our automatic SPAM detection filter.\")\
				) then\
					specialPrint(\"You must go to '\", url, \"' and do the Captcha to be able to download that paste.\", colors.yellow)\
					return false\
				end\
\
				setTextColor(colors.lightGray)\
				sWrite(\"Parsing archive...\")\
				archive = parseArchiveData(contents)\
				if archive then\
					setTextColor(colors.green)\
					sPrint(\"good\")\
				else\
					setTextColor(colors.red)\
					sPrint(\"Invalid archive file.\")\
					return false\
				end\
				if doOverwrite then\
					fs.delete(outputPath)\
				end\
				writeArchiveData(archive, outputPath)\
			else\
				setTextColor(colors.red)\
				sPrint(\"failed!\")\
				setTextColor(colors.white)\
				return false\
			end\
		end\
	else -- regular unpack\
		if exists then\
			if fs.isReadOnly(outputPath) then\
				error(\"Output path is read-only.\")\
			elseif fs.exists(outputPath) and (outputPath ~= inputPath) or outputPath == shell.getRunningProgram() then\
				doContinue, doOverwrite = overwriteOutputPath(inputPath, outputPath, true, justOverwrite)\
			end\
			if not doContinue then\
				return false\
			elseif outputPath == inputPath then\
				doOverwrite = true\
			end\
			setTextColor(colors.lightGray)\
			sWrite(\"Parsing archive...\")\
			archive = parseArchive(inputPath)\
			if archive then\
				setTextColor(colors.green)\
				sPrint(\"good\")\
				if doOverwrite then\
					fs.delete(outputPath)\
				end\
				writeArchiveData(archive, outputPath)\
			else\
				setTextColor(colors.red)\
				sPrint(\"Invalid archive file.\")\
				return false\
			end\
		else\
			error(\"No such input path exists.\")\
		end\
	end\
\
elseif mode == \"inspect\" then\
\
	if exists and (not fs.isDir(inputPath)) then\
		archive = parseArchive(inputPath, true)\
		local totalSize = 0\
		local amountOfFiles = 0\
		local averageSize = 0\
\
		local output = {}\
\
		if archive then\
			for k,v in pairs(archive) do\
				if k == \"data\" then\
					for name, contents in pairs(v) do\
						if contents then -- don't count directories, where contents == false\
							totalSize = totalSize + #contents\
							amountOfFiles = amountOfFiles + 1\
						end\
					end\
					averageSize = math.ceil(totalSize / amountOfFiles)\
				else\
					output[#output + 1] = k .. \" = \\\"\" .. tostring(v) .. \"\\\"\"\
				end\
			end\
			sPrint(\"# of files: \" .. amountOfFiles)\
			sPrint(\"Total size: \" .. totalSize .. \" bytes (\" .. round(totalSize / 1024, 1) .. \" KB)\")\
			sPrint(\"Aveg. size: \" .. averageSize .. \" bytes (\" .. round(averageSize / 1024, 1) .. \" KB)\")\
			sPrint((\"-\"):rep(scr_x))\
			for i = 1, #output do\
				sPrint(output[i])\
			end\
		else\
			error(\"Invalid archive file.\")\
		end\
	else\
		if fs.isDir(inputPath) then\
			error(\"Cannot inspect directories.\")\
		else\
			error(\"No such input path exists.\")\
		end\
	end\
\
end",
    [ "sys/apps/.metros.lua" ] = "local tArgs = {...}\
local cmd = tArgs[1]\
local cmd2 = tArgs[2]\
local cmd3 = tArgs[3]\
if cmd ==\"help\"then\
  print(\"HELP\")\
elseif cmd==\"startup\" then\
  if cmd2==\"reset\" then\
  shell.setDir(\"./\")\
  shell.run(\"wget\", \"https://raw.githubusercontent.com/Fleench/CC-Metros/main/startup.lua\", \"startup\")\
  shell.setDir(\"/metros/sys/apps\")\
  end\
elseif cmd==\"reset\" then\
  shell.setDir(\"./\")\
  shell.run(\"delete\",\"/metros\")\
  shell.run(\"wget\",\"run\",\"http://cc.metros-install.flench.me\")\
elseif cmd==\"remove\" then\
  shell.setDir(\"./\")\
  shell.run(\"delete\",\"/metros\")\
end",
    [ "sys/apps/enchat3.lua" ] = "--[[\
 Enchat 3.0\
 Get with:\
  wget https://github.com/LDDestroier/enchat/raw/master/enchat3.lua enchat3.lua\
\
This is a stable release. You fool!\
--]]\
\
local scr_x, scr_y = term.getSize()\
CHATBOX_SAFEMODE = nil\
\
-- non-changable settings\
enchat = {\
	connectToSkynet = true,\
	version = 3.0,\
	isBeta = false,\
	port = 11000,\
	skynetPort = \"enchat3-default\",\
	url = \"https://github.com/LDDestroier/enchat/raw/master/enchat3.lua\",\
	betaurl = \"https://github.com/LDDestroier/enchat/raw/beta/enchat3.lua\",\
	ignoreModem = false,\
	dataDir = \"/.enchat\",\
	useChatbox = false,\
	disableChatboxWithRedstone = false,\
}\
\
-- changable settings\
local enchatSettings = {	-- DEFAULT settings.\
	animDiv = 4,			-- divisor of text animation speed (scrolling from left)\
	doAnimate = true,		-- whether or not to animate text moving from left side of screen\
	reverseScroll = false,	-- whether or not to make scrolling up really scroll down\
	redrawDelay = 0.1,		-- delay between redrawing\
	useSetVisible = false,	-- whether or not to use term.current().setVisible(), which has performance and flickering improvements\
	pageKeySpeed = 8,		-- how far PageUP or PageDOWN should scroll\
	doNotif = true,			-- whether or not to use oveerlay glasses for notifications, if possible\
	doKrazy = true,			-- whether or not to add &k obfuscation\
	useSkynet = true,		-- whether or not to use gollark's Skynet in addition to modem calls\
	extraNewline = true,	-- adds an extra newline after every message since setting to true\
	acceptPictoChat = true,	-- whether or not to allow tablular enchat input, which is what /picto uses\
	noRepeatNames = true,	-- whether or not to display the username in two or more consecutive messages by the same user\
}\
\
-- colors for various elements\
palette = {\
	bg = colors.black,\
	txt = colors.white,\
	promptbg = colors.gray,\
	prompttxt = colors.white,\
	scrollMeter = colors.lightGray,\
	chevron = colors.black,\
	title = colors.lightGray,\
	titlebg = colors.gray,\
}\
\
-- UI adjustments, used to emulate the appearance of other chat programs\
UIconf = {\
	promptY = 1,\
	chevron = \">\",\
	chatlogTop = 1,\
	title = \"Enchat 3\",\
	doTitle = false,\
	titleY = 1,\
	nameDecolor = false,\
	centerTitle = true,\
	prefix = \"<\",\
	suffix = \"> \"\
}\
\
-- Attempt to get some slight optimization through localizing basic functions.\
local mathmax, mathmin, mathrandom = math.max, math.min, math.random\
local termblit, termwrite = term.blit, term.write\
local termsetCursorPos, termgetCursorPos, termsetCursorBlink = term.setCursorPos, term.getCursorPos, term.setCursorBlink\
local termsetTextColor, termsetBackgroundColor = term.setTextColor, term.setBackgroundColor\
local termgetTextColor, termgetBackgroundColor = term.getTextColor, term.getBackgroundColor\
local termclear, termclearLine = term.clear, term.clearLine\
local tableinsert, tableremove, tableconcat = table.insert, table.remove, table.concat\
local textutilsserialize, textutilsunserialize = textutils.serialize, textutils.unserialize\
local stringsub, stringgsub, stringrep = string.sub, string.gsub, string.rep\
local unpack = unpack\
-- This better do something.\
\
local initcolors = {\
	bg = termgetBackgroundColor(),\
	txt = termgetTextColor()\
}\
\
local tArg = {...}\
\
local yourName = tArg[1]\
local encKey = tArg[2]\
\
local setEncKey = function(newKey)\
	encKey = newKey\
end\
\
local saveSettings = function()\
	local file = fs.open(fs.combine(enchat.dataDir, \"settings\"), \"w\")\
	file.write(\
		textutilsserialize({\
			enchatSettings = enchatSettings,\
			palette = palette,\
			UIconf = UIconf,\
		})\
	)\
	file.close()\
end\
\
local loadSettings = function()\
	local contents\
	if not fs.exists(fs.combine(enchat.dataDir, \"settings\")) then\
		saveSettings()\
	end\
	local file = fs.open(fs.combine(enchat.dataDir, \"settings\"), \"r\")\
	contents = file.readAll()\
	file.close()\
	local newSettings = textutilsunserialize(contents)\
	if newSettings then\
		for k,v in pairs(newSettings.enchatSettings) do\
			enchatSettings[k] = v\
		end\
		for k,v in pairs(newSettings.palette) do\
			palette[k] = v\
		end\
		for k,v in pairs(newSettings.UIconf) do\
			UIconf[k] = v\
		end\
	else\
		saveSettings()\
	end\
end\
\
local updateEnchat = function(doBeta)\
	local pPath = shell.getRunningProgram()\
	local h = http.get((doBeta or enchat.isBeta) and enchat.betaurl or enchat.url)\
	if not h then\
		return false, \"Could not connect.\"\
	else\
		local content = h.readAll()\
		local file = fs.open(pPath, \"w\")\
		file.write(content)\
		file.close()\
		return true, \"Updated!\"\
	end\
end\
\
-- disables chat screen updating\
local pauseRendering = true\
\
-- primarily for use when using the pallete command, hoh hoh\
local colors_strnames = {\
	[\"white\"] = colors.white,\
	[\"pearl\"] = colors.white,\
	[\"silver\"] = colors.white,\
	[\"aryan\"] = colors.white,\
	[\"#f0f0f0\"] = colors.white,\
\
	[\"orange\"] = colors.orange,\
	[\"carrot\"] = colors.orange,\
	[\"fuhrer\"] = colors.orange,\
	[\"pumpkin\"] = colors.orange,\
	[\"#f2b233\"] = colors.orange,\
\
	[\"magenta\"] = colors.magenta,\
	[\"hotpink\"] = colors.magenta,\
	[\"lightpurple\"] = colors.magenta,\
	[\"light purple\"] = colors.magenta,\
	[\"#e57fd8\"] = colors.magenta,\
\
	[\"lightblue\"] = colors.lightBlue,\
	[\"light blue\"] = colors.lightBlue,\
	[\"skyblue\"] = colors.lightBlue,\
	[\"#99b2f2\"] = colors.lightBlue,\
\
	[\"yellow\"] = colors.yellow,\
	[\"piss\"] = colors.yellow,\
	[\"pee\"] = colors.yellow,\
	[\"lemon\"] = colors.yellow,\
	[\"spongebob\"] = colors.yellow,\
	[\"cowardice\"] = colors.yellow,\
	[\"#dede6c\"] = colors.yellow,\
\
	[\"lime\"] = colors.lime,\
	[\"lightgreen\"] = colors.lime,\
	[\"light green\"] = colors.lime,\
	[\"slime\"] = colors.lime,\
	[\"radiation\"] = colors.lime,\
	[\"#7fcc19\"] = colors.lime,\
\
	[\"pink\"] = colors.pink,\
	[\"lightishred\"] = colors.pink,\
	[\"lightish red\"] = colors.pink,\
	[\"communist\"] = colors.pink,\
	[\"commie\"] = colors.pink,\
	[\"patrick\"] = colors.pink,\
	[\"#f2b2cc\"] = colors.pink,\
\
	[\"gray\"] = colors.gray,\
	[\"grey\"] = colors.gray,\
	[\"graey\"] = colors.gray,\
	[\"gunmetal\"] = colors.gray,\
	[\"#4c4c4c\"] = colors.gray,\
\
	[\"lightgray\"] = colors.lightGray,\
	[\"lightgrey\"] = colors.lightGray,\
	[\"light gray\"] = colors.lightGray,\
	[\"light grey\"] = colors.lightGray,\
	[\"#999999\"] = colors.lightGray,\
\
	[\"cyan\"] = colors.cyan,\
	[\"seawater\"] = colors.cyan,\
	[\"brine\"] = colors.cyan,\
	[\"#4c99b2\"] = colors.cyan,\
\
	[\"purple\"] = colors.purple,\
	[\"purble\"] = colors.purple,\
	[\"obsidian\"] = colors.purple,\
	[\"diviner\"] = colors.purple,\
	[\"#b266e5\"] = colors.purple,\
\
	[\"blue\"] = colors.blue,\
	[\"blu\"] = colors.blue,\
	[\"azure\"] = colors.blue,\
	[\"sapphire\"] = colors.blue,\
	[\"lapis\"] = colors.blue,\
	[\"volnutt\"] = colors.blue,\
	[\"blueberry\"] = colors.blue,\
	[\"x\"] = colors.blue,\
	[\"megaman\"] = colors.blue,\
	[\"#3366bb\"] = colors.blue,\
\
	[\"brown\"] = colors.brown,\
	[\"shit\"] = colors.brown,\
	[\"dirt\"] = colors.brown,\
	[\"mud\"] = colors.brown,\
	[\"bricks\"] = colors.brown,\
	[\"#7f664c\"] = colors.brown,\
\
	[\"green\"] = colors.green,\
	[\"grass\"] = colors.green,\
	[\"#57a64e\"] = colors.green,\
\
	[\"red\"] = colors.red,\
	[\"crimson\"] = colors.red,\
	[\"vermillion\"] = colors.red,\
	[\"menstration\"] = colors.red,\
	[\"blood\"] = colors.red,\
	[\"marinara\"] = colors.red,\
	[\"zero\"] = colors.red,\
	[\"protoman\"] = colors.red,\
	[\"communism\"] = colors.red,\
	[\"#cc4c4c\"] = colors.red,\
\
	[\"black\"] = colors.black,\
	[\"dark\"] = colors.black,\
	[\"darkness\"] = colors.black,\
	[\"space\"] = colors.black,\
	[\"coal\"] = colors.black,\
	[\"onyx\"] = colors.black,\
	[\"#191919\"] = colors.black,\
}\
\
local toblit = {\
	[0] = \" \",\
	[1] = \"0\",\
	[2] = \"1\",\
	[4] = \"2\",\
	[8] = \"3\",\
	[16] = \"4\",\
	[32] = \"5\",\
	[64] = \"6\",\
	[128] = \"7\",\
	[256] = \"8\",\
	[512] = \"9\",\
	[1024] = \"a\",\
	[2048] = \"b\",\
	[4096] = \"c\",\
	[8192] = \"d\",\
	[16384] = \"e\",\
	[32768] = \"f\"\
}\
local tocolors = {}\
for k,v in pairs(toblit) do\
	tocolors[v] = k\
end\
\
local codeNames = {\
	[\"r\"] = \"reset\",		-- Sets either the text (&) or background (~) colors to their original color.\
	[\"{\"] = \"stopFormatting\",	-- Toggles formatting text off\
	[\"}\"] = \"startFormatting\",	-- Toggles formatting text on\
	[\"k\"] = \"krazy\"			-- Makes the font kuh-razy!\
}\
\
-- indicates which character should turn into which random &k character\
local kraziez = {\
	[\"l\"] = {\
		\"!\",\
		\"l\",\
		\"1\",\
		\"|\",\
		\"i\",\
		\"I\",\
		\":\",\
		\";\",\
	},\
	[\"m\"] = {\
		\"M\",\
		\"W\",\
		\"w\",\
		\"m\",\
		\"X\",\
		\"N\",\
		\"_\",\
		\"%\",\
		\"@\",\
	},\
	[\"all\"] = {}\
}\
\
for a = 1, #kraziez[\"l\"] do\
	kraziez[kraziez[\"l\"][a]] = kraziez[\"l\"]\
end\
for k,v in pairs(kraziez) do\
	for a = 1, #v do\
		kraziez[kraziez[k][a]] = v\
	end\
end\
\
-- check if using older CC version, and omit special characters if it's too old to avoid crash\
if tonumber(_CC_VERSION or 0) >= 1.76 then\
	for a = 1, 255 do\
		if (a ~= 32) and (a ~= 13) and (a ~= 10) then\
			kraziez[\"all\"][#kraziez[\"all\"]+1] = string.char(a)\
		end\
	end\
else\
	for a = 33, 126 do\
		kraziez[\"all\"][#kraziez[\"all\"]+1] = string.char(a)\
	end\
end\
\
local makeRandomString = function(length, begin, stop)\
	local output = \"\"\
	for a = 1, length do\
		output = output .. string.char(math.random(begin or 1, stop or 255))\
	end\
	return output\
end\
\
local personalID = makeRandomString(64, 32, 128)\
\
local explode = function(div, str, replstr, includeDiv)\
	if (div == '') then\
		return false\
	end\
	local pos, arr = 0, {}\
	for st, sp in function() return string.find(str, div, pos, false) end do\
		tableinsert(arr, string.sub(replstr or str, pos, st - 1 + (includeDiv and #div or 0)))\
		pos = sp + 1\
	end\
	tableinsert(arr, string.sub(replstr or str, pos))\
	return arr\
end\
\
local parseKrazy = function(c)\
	if kraziez[c] then\
		return kraziez[c][mathrandom(1, #kraziez[c])]\
	else\
		return kraziez.all[mathrandom(1, #kraziez.all)]\
	end\
end\
\
-- my main man, the function that turns unformatted strings into formatted strings\
local textToBlit = function(input, onlyString, initText, initBack, checkPos, useJSONformat)\
	if not input then return end\
	checkPos = checkPos or -1\
	initText, initBack = initText or toblit[term.getTextColor()], initBack or toblit[term.getBackgroundColor()]\
	tcode, bcode = \"&\", \"~\"\
	local cpos, cx = 0, 0\
	local skip, ignore, ex = nil, false, nil\
	local text, back, nex = initText, initBack, nil\
\
	local charOut, textOut, backOut = {}, {}, {}\
	local JSONoutput = {}\
\
	local krazy = false\
	local bold = false\
	local strikethrough = false\
	local underline = false\
	local italic = false\
\
	local codes = {}\
	codes[\"r\"] = function(prev)\
		if not ignore then\
			if prev == tcode then\
				text = initText\
				bold = false\
				strikethrough = false\
				underline = false\
				italic = false\
			elseif prev == bcode then\
				if useJSONformat then\
					return 0\
				else\
					back = initBack\
				end\
			end\
			krazy = false\
		else\
			return 0\
		end\
	end\
	codes[\"k\"] = function(prev)\
		if not ignore then\
			krazy = not krazy\
		else\
			return 0\
		end\
	end\
	codes[\"{\"] = function(prev)\
		if not ignore then\
			ignore = true\
		else\
			return 0\
		end\
	end\
	codes[\"}\"] = function(prev)\
		if ignore then\
			ignore = false\
		else\
			return 0\
		end\
	end\
\
	if useJSONformat then\
		codes[\"l\"] = function(prev)\
			bold = true\
		end\
		codes[\"m\"] = function(prev)\
			strikethrough = true\
		end\
		codes[\"n\"] = function(prev)\
			underline = true\
		end\
		codes[\"o\"] = function(prev)\
			italic = true\
		end\
	end\
\
	local sx, str = 0\
	input = stringgsub(input, \"(\\\\)(%d%d?%d?)\", function(cap, val)\
		if tonumber(val) < 256 then\
			cpos = cpos - #val\
			return string.char(val)\
		else\
			return cap..val\
		end\
	end)\
\
	local MCcolors = {\
		[\"0\"] = \"white\",\
		[\"1\"] = \"gold\",\
		[\"2\"] = \"light_purple\",\
		[\"3\"] = \"aqua\",\
		[\"4\"] = \"yellow\",\
		[\"5\"] = \"green\",\
		[\"6\"] = \"light_purple\",\
		[\"7\"] = \"dark_gray\",\
		[\"8\"] = \"gray\",\
		[\"9\"] = \"dark_aqua\",\
		[\"a\"] = \"dark_purple\",\
		[\"b\"] = \"dark_blue\",\
		[\"c\"] = \"gold\",\
		[\"d\"] = \"dark_green\",\
		[\"e\"] = \"red\",\
		[\"f\"] = \"black\",\
	}\
\
	for cx = 1, #input do\
		str = stringsub(input,cx,cx)\
		if skip then\
			if tocolors[str] and not ignore then\
				if skip == tcode then\
					text = str == \" \" and initText or str\
					if sx < checkPos then\
						cpos = cpos - 2\
					end\
				elseif skip == bcode then\
					back = str == \" \" and initBack or str\
					if sx < checkPos then\
						cpos = cpos - 2\
					end\
				end\
			elseif codes[str] and not (ignore and str == \"{\") then\
				ex = codes[str](skip) or 0\
				sx = sx + ex\
    				if sx < checkPos then\
					cpos = cpos - ex - 2\
				end\
			else\
				sx = sx + 1\
				if useJSONformat then\
					JSONoutput[sx] = {\
						text = (skip..str),\
						color = onlyString and \"f\" or MCcolors[text],\
						bold = (not onlyString) and bold,\
						italic = (not onlyString) and italic,\
						underline = (not onlyString) and underline,\
						obfuscated = (not onlyString) and krazy,\
						strikethrough = (not onlyString) and strikethrough\
					}\
				else\
					charOut[sx] = krazy and parseKrazy(prev..str) or (skip..str)\
					textOut[sx] = stringrep(text,2)\
					backOut[sx] = stringrep(back,2)\
				end\
			end\
			skip = nil\
		else\
			if (str == tcode or str == bcode) and (codes[stringsub(input, 1+cx, 1+cx)] or tocolors[stringsub(input,1+cx,1+cx)]) then\
				skip = str\
			else\
				sx = sx + 1\
				if useJSONformat then\
					JSONoutput[sx] = {\
						text = str,\
						color = onlyString and \"f\" or MCcolors[text],\
						bold = (not onlyString) and bold,\
						italic = (not onlyString) and italic,\
						underline = (not onlyString) and underline,\
						obfuscated = (not onlyString) and krazy,\
						strikethrough = (not onlyString) and strikethrough\
					}\
				else\
					charOut[sx] = krazy and parseKrazy(str) or str\
					textOut[sx] = text\
					backOut[sx] = back\
				end\
			end\
		end\
	end\
	if useJSONformat then\
		return textutils.serializeJSON(JSONoutput)\
	else\
		if onlyString then\
			return tableconcat(charOut), (checkPos > -1) and cpos or nil\
		else\
--			return {tableconcat(charOut), tableconcat(textOut):gsub(\" \", initText), tableconcat(backOut):gsub(\" \", initBack)}, (checkPos > -1) and cpos or nil\
			return {tableconcat(charOut), tableconcat(textOut), tableconcat(backOut)}, (checkPos > -1) and cpos or nil\
		end\
	end\
end\
_G.textToBlit = textToBlit\
\
-- convoluted read function that renders color codes as they are written.\
-- struggles with \\123 codes, but hey, fuck you\
local colorRead = function(maxLength, _history)\
	local output = \"\"\
	local history, _history = {}, _history or {}\
	for a = 1, #_history do\
		history[a] = _history[a]\
	end\
	history[#history+1] = \"\"\
	local hPos = #history\
	local cx, cy = termgetCursorPos()\
	local x, xscroll = 1, 1\
	local ctrlDown = false\
	termsetCursorBlink(true)\
	local evt, key, bout, xmod, timtam\
	while true do\
		termsetCursorPos(cx, cy)\
		bout, xmod = textToBlit(output, false, nil, nil, x)\
		for a = 1, #bout do\
			bout[a] = stringsub(bout[a], xscroll, xscroll + scr_x - cx)\
		end\
		termblit(unpack(bout))\
		termwrite((\" \"):rep(scr_x - cx))\
		termsetCursorPos(cx + x + xmod - xscroll, cy)\
		evt = {os.pullEvent()}\
		if evt[1] == \"char\" or evt[1] == \"paste\" then\
			output = (output:sub(1, x-1)..evt[2]..output:sub(x)):sub(1, maxLength or -1)\
			x = mathmin(x + #evt[2], #output+1)\
		elseif evt[1] == \"key\" then\
			key = evt[2]\
			if key == keys.leftCtrl then\
				ctrlDown = true\
			elseif key == keys.left then\
				x = mathmax(x - 1, 1)\
			elseif key == keys.right then\
				x = mathmin(x + 1, #output+1)\
			elseif key == keys.backspace then\
				if x > 1 then\
					repeat\
						output = output:sub(1,x-2)..output:sub(x)\
						x = x - 1\
					until output:sub(x-1,x-1) == \" \" or (not ctrlDown) or (x == 1)\
				end\
			elseif key == keys.delete then\
				if x < #output+1 then\
					repeat\
						output = output:sub(1,x-1)..output:sub(x+1)\
					until output:sub(x,x) == \" \" or (not ctrlDown) or (x == #output+1)\
				end\
			elseif key == keys.enter then\
				termsetCursorBlink(false)\
				return output\
			elseif key == keys.home then\
				x = 1\
			elseif key == keys[\"end\"] then\
				x = #output+1\
			elseif key == keys.up then\
				if history[hPos-1] then\
					hPos = hPos - 1\
					output = history[hPos]\
					x = #output+1\
				end\
			elseif key == keys.down then\
				if history[hPos+1] then\
					hPos = hPos + 1\
					output = history[hPos]\
					x = #output+1\
				end\
			end\
		elseif evt[1] == \"key_up\" then\
			if evt[2] == keys.leftCtrl then\
				ctrlDown = false\
			end\
		end\
		if hPos > 1 then\
			history[hPos] = output\
		end\
		if x+cx-xscroll+xmod > scr_x then\
			xscroll = x-(scr_x-cx)+xmod\
		elseif x-xscroll+xmod < 0 then\
			repeat\
				xscroll = xscroll - 1\
			until x-xscroll-xmod >= 0\
		end\
		xscroll = math.max(1, xscroll)\
	end\
end\
_G.colorRead = colorRead\
\
local checkValidName = function(_nayme)\
	local nayme = textToBlit(_nayme,true)\
	if type(nayme) ~= \"string\" then\
		return false\
	else\
		return (#nayme >= 2 and #nayme <= 32 and nayme:gsub(\" \",\"\") ~= \"\")\
	end\
end\
\
if tArg[1] == \"update\" then\
	local res, message = updateEnchat(tArg[2] == \"beta\")\
	return print(message)\
end\
\
local prettyClearScreen = function(start, stop)\
	termsetTextColor(colors.lightGray)\
	termsetBackgroundColor(colors.gray)\
	if _VERSION then\
		for y = start or 1, stop or scr_y do\
			termsetCursorPos(1,y)\
			if y == (start or 1) then\
				termwrite((\"\\135\"):rep(scr_x))\
			elseif y == (stop or scr_y) then\
				termsetTextColor(colors.gray)\
				termsetBackgroundColor(colors.lightGray)\
				termwrite((\"\\135\"):rep(scr_x))\
			else\
				termclearLine()\
			end\
		end\
	else\
		termclear()\
	end\
end\
\
local cwrite = function(text, y)\
	local cx, cy = termgetCursorPos()\
	termsetCursorPos((scr_x/2) - math.ceil(#text/2), y or cy)\
	return write(text)\
end\
\
local prettyCenterWrite = function(text, y)\
	local words = explode(\" \", text, nil, true)\
	local buff = \"\"\
	local lines = 0\
	for w = 1, #words do\
		if #buff + #words[w] > scr_x then\
			cwrite(buff, y + lines)\
			buff = \"\"\
			lines = lines + 1\
		end\
		buff = buff..words[w]\
	end\
	cwrite(buff, y + lines)\
	return lines\
end\
\
local prettyPrompt = function(prompt, y, replchar, doColor)\
	local cy, cx = termgetCursorPos()\
	termsetBackgroundColor(colors.gray)\
	termsetTextColor(colors.white)\
	local yadj = 1 + prettyCenterWrite(prompt, y or cy)\
	termsetCursorPos(1, y + yadj)\
	termsetBackgroundColor(colors.lightGray)\
	termclearLine()\
	local output\
	if doColor then\
		output = colorRead()\
	else\
		output = read(replchar)\
	end\
	return output\
end\
\
local fwrite = function(text)\
	local b = textToBlit(text)\
	return termblit(unpack(b))\
end\
\
local cfwrite = function(text, y)\
	local cx, cy = termgetCursorPos()\
	termsetCursorPos((scr_x/2) - math.ceil(#textToBlit(text,true)/2), y or cy)\
	return fwrite(text)\
end\
\
-- execution start!\
\
if not checkValidName(yourName) then -- not so fast, evildoers\
	yourName = nil\
end\
\
local currentY = 2\
\
if not (yourName and encKey) then\
	prettyClearScreen()\
end\
\
if not yourName then\
    cfwrite(\"&8~7Text = &, Background = ~\", scr_y-3)\
	cfwrite(\"&8~7&{Krazy = &k, Reset = &r\", scr_y-2)\
    cfwrite(\"&7~00~11~22~33~44~55~66&8~77&7~88~99~aa~bb~cc~dd~ee~ff\", scr_y-1)\
	yourName = prettyPrompt(\"Enter your name.\", currentY, nil, true)\
	if not checkValidName(yourName) then\
		while true do\
			yourName = prettyPrompt(\"That name isn't valid. Enter another.\", currentY, nil, true)\
			if checkValidName(yourName) then\
				break\
			end\
		end\
	end\
	currentY = currentY + 3\
end\
\
if not encKey then\
	setEncKey(prettyPrompt(\"Enter an encryption key.\", currentY, \"*\"))\
	currentY = currentY + 3\
end\
\
-- prevents terminating. it is reversed upon exit.\
local oldePullEvent = os.pullEvent\
os.pullEvent = os.pullEventRaw\
\
local bottomMessage = function(text)\
	termsetCursorPos(1,scr_y)\
	termsetTextColor(colors.gray)\
	termclearLine()\
	termwrite(text)\
end\
\
loadSettings()\
saveSettings()\
\
termsetBackgroundColor(colors.black)\
termclear()\
\
local getAPI = function(apiname, apipath, apiurl, doDoFile, doScroll)\
	apipath = fs.combine(fs.combine(enchat.dataDir,\"api\"), apipath)\
	if (not fs.exists(apipath)) then\
		if doScroll then term.scroll(1) end\
		bottomMessage(apiname .. \" API not found! Downloading...\")\
		local prog = http.get(apiurl)\
		if not prog then\
			if doScroll then term.scroll(1) end\
			bottomMessage(\"Failed to download \" .. apiname .. \" API. Abort.\")\
			termsetCursorPos(1,1)\
			return\
		end\
		local file = fs.open(apipath,\"w\")\
		file.write(prog.readAll())\
		file.close()\
	end\
	if doDoFile then\
		return dofile(apipath)\
	else\
		os.loadAPI(apipath)\
	end\
	if not _ENV[fs.getName(apipath)] then\
		if doScroll then term.scroll(1) end\
		bottomMessage(\"Failed to load \" .. apiname .. \" API. Abort.\")\
		termsetCursorPos(1,1)\
		return\
	else\
		return _ENV[fs.getName(apipath)]\
	end\
end\
\
local skynet, aes, bigfont\
-- _G.skynet_CBOR_path = fs.combine(enchat.dataDir,\"/api/cbor\")\
aes = getAPI(\"AES\", \"aes\", \"http://pastebin.com/raw/9E5UHiqv\", false, false)\
if enchat.connectToSkynet and http.websocket then\
	skynet = getAPI(\"Skynet\", \"skynet\", \"https://raw.githubusercontent.com/LDDestroier/CC/master/API/skynet.lua\", true, true)\
end\
bigfont = getAPI(\"BigFont\", \"bigfont\", \"https://pastebin.com/raw/3LfWxRWh\", false, true)\
\
if encKey and skynet and enchat.connectToSkynet then\
	bottomMessage(\"Connecting to Skynet...\")\
	local success = parallel.waitForAny(\
		function()\
			skynet.open(enchat.skynetPort)\
		end,\
		function()\
			sleep(3)\
		end\
	)\
	if success == 2 then\
		term.scroll(1)\
		bottomMessage(\"Failed to connect to skynet.\")\
		skynet = nil\
		sleep(0.5)\
	end\
end\
\
local log = {} 			-- Records all sorts of data on text.\
local renderlog = {} 	-- Only records straight terminal output. Generated from 'log'\
local IDlog = {} 		-- Really only used with skynet, will prevent duplicate messages.\
\
local scroll = 0\
local maxScroll = 0\
\
local getModem = function()\
	if enchat.ignoreModem then\
		return nil\
	else\
		local modems = {peripheral.find(\"modem\")}\
		return modems[1]\
	end\
end\
\
local getChatbox = function()\
	if enchat.useChatbox then\
		if commands then -- oh baby, a command computer, now we're talkin'\
			-- mind you, you still need a chatbox to get chat input...\
			return {\
				say = function(text)\
					commands.tellraw(\"@a\", textToBlit(text, false, \"0\", \"f\", nil, true))\
				end,\
				tell = function(player, text)\
					commands.tellraw(player, textToBlit(text, false, \"0\", \"f\", nil, true))\
				end\
			}\
		else\
			local cb = chatbox or peripheral.find(\"chat_box\")\
			if cb then\
				if cb.setName then -- Computronics\
					cb.setName(yourName)\
					return {\
						say = cb.say,\
						tell = cb.say -- why is there no tell command???\
					}\
				else -- whatever whackjob mod SwitchCraft uses I forget\
					return {\
						say = function(text, block)\
							if CHATBOX_SAFEMODE then\
--								if CHATBOX_SAFEMODE ~= block then\
									cb.tell(CHATBOX_SAFEMODE, text)\
--								end\
							else\
								local players = cb.getPlayerList()\
								for i = 1, #players do\
									if players[i] ~= block then\
										cb.tell(players[i], text)\
									end\
								end\
							end\
						end,\
						tell = cb.tell\
					}\
				end\
			else\
				return nil\
			end\
		end\
	else\
		return nil\
	end\
end\
\
local modem = getModem()\
local chatbox = getChatbox()\
\
if (not modem) and (not enchat.ignoreModem) then\
	if ccemux and (not enchat.ignoreModem) then\
		ccemux.attach(\"top\", \"wireless_modem\")\
		modem = getModem()\
	elseif not skynet then\
		error(\"You should get a modem.\")\
	end\
end\
\
if modem then modem.open(enchat.port) end\
\
local modemTransmit = function(freq, repfreq, message)\
	if modem then\
		modem.transmit(freq, repfreq, message)\
	end\
end\
\
local encrite = function(input) -- standardized encryption function\
	if not input then return input end\
	return aes.encrypt(encKey, textutilsserialize(input))\
end\
\
local decrite = function(input) -- redundant comments cause tuberculosis\
	if not input then return input end\
	return textutilsunserialize(aes.decrypt(encKey, input) or \"\")\
end\
\
local dab = function(func, ...) -- \"do and back\", not...never mind\
	local x, y = termgetCursorPos()\
	local b, t = termgetBackgroundColor(), termgetTextColor()\
	local output = {func(...)}\
	termsetCursorPos(x,y)\
	termsetTextColor(t)\
	termsetBackgroundColor(b)\
	return unpack(output)\
end\
\
local splitStr = function(str, maxLength)\
	local output = {}\
	for l = 1, #str, maxLength do\
		output[#output+1] = str:sub(l,l+maxLength+-1)\
	end\
	return output\
end\
\
local splitStrTbl = function(tbl, maxLength)\
	local output, tline = {}\
	for w = 1, #tbl do\
		tline = splitStr(tbl[w], maxLength)\
		for t = 1, #tline do\
			output[#output+1] = tline[t]\
		end\
	end\
	return output\
end\
\
-- same as term.blit, but wraps by-word.\
local blitWrap = function(char, text, back, noWrite) -- where ALL of the onscreen wrapping is done\
	local cWords = splitStrTbl(explode(\" \",char,nil, true), scr_x)\
	local tWords = splitStrTbl(explode(\" \",char,text,true), scr_x)\
	local bWords = splitStrTbl(explode(\" \",char,back,true), scr_x)\
\
	local ox,oy = termgetCursorPos()\
	local cx,cy,ty = ox,oy,1\
	local output = {}\
	local length = 0\
	local maxLength = 0\
	for a = 1, #cWords do\
		length = length + #cWords[a]\
		maxLength = mathmax(maxLength, length)\
		if ((cx + #cWords[a]) > scr_x) then\
			cx = 1\
			length = 0\
			if (cy == scr_y) then\
				term.scroll(1)\
			end\
			cy = mathmin(cy+1, scr_y)\
			ty = ty + 1\
		end\
		if not noWrite then\
			termsetCursorPos(cx,cy)\
			termblit(cWords[a],tWords[a],bWords[a])\
		end\
		cx = cx + #cWords[a]\
		output[ty] = output[ty] or {\"\",\"\",\"\"}\
		output[ty][1] = output[ty][1]..cWords[a]\
		output[ty][2] = output[ty][2]..tWords[a]\
		output[ty][3] = output[ty][3]..bWords[a]\
	end\
	return output, maxLength\
end\
\
-- simple picture drawing function, for /picto\
local pictochat = function(xsize, ysize)\
	local output = {{},{},{}}\
	local maxWidth, minMargin = 0, math.huge\
	for y = 1, ysize do\
		output[1][y] = {}\
		output[2][y] = {}\
		output[3][y] = {}\
		for x = 1, xsize do\
			output[1][y][x] = \" \"\
			output[2][y][x] = \" \"\
			output[3][y][x] = \" \"\
		end\
	end\
\
	termsetBackgroundColor(colors.gray)\
	termsetTextColor(colors.black)\
	for y = 1, scr_y do\
		termsetCursorPos(1, y)\
		termwrite((\"/\"):rep(scr_x))\
	end\
	cwrite(\" [ENTER] to finish. \", scr_y)\
	cwrite(\"Push a key to change char.\", scr_y-1)\
\
	local cx, cy = math.floor((scr_x/2)-(xsize/2)), math.floor((scr_y/2)-(ysize/2))\
\
	local allCols = \"0123456789abcdef\"\
	local tPos, bPos = 16, 1\
	local char, text, back = \" \", allCols:sub(tPos,tPos), allCols:sub(bPos,bPos)\
\
	local render = function()\
		termsetTextColor(colors.white)\
		termsetBackgroundColor(colors.black)\
		local mx, my\
		for y = 1, ysize do\
			for x = 1, xsize do\
				mx, my = x+cx+-1, y+cy+-1\
				termsetCursorPos(mx,my)\
				termblit(output[1][y][x], output[2][y][x], output[3][y][x])\
			end\
		end\
		termsetCursorPos((scr_x/2)-5,ysize+cy+1)\
		termwrite(\"Char = '\")\
		termblit(char, text, back)\
		termwrite(\"'\")\
	end\
	local evt, butt, mx, my\
	local isShiftDown = false\
\
	render()\
\
	while true do\
		evt = {os.pullEvent()}\
		if evt[1] == \"mouse_click\" or evt[1] == \"mouse_drag\" then\
			butt, mx, my = evt[2], evt[3]-cx+1, evt[4]-cy+1\
			if mx >= 1 and mx <= xsize and my >= 1 and my <= ysize then\
				if butt == 1 then\
					output[1][my][mx] = char\
					output[2][my][mx] = text\
					output[3][my][mx] = back\
				elseif butt == 2 then\
					output[1][my][mx] = \" \"\
					output[2][my][mx] = \" \"\
					output[3][my][mx] = \" \"\
				end\
				render()\
			end\
		elseif evt[1] == \"mouse_scroll\" then\
			local oldTpos, oldBpos = tPos, bPos\
			if isShiftDown then\
				tPos = mathmax(1, mathmin(16, tPos + evt[2]))\
			else\
				bPos = mathmax(1, mathmin(16, bPos + evt[2]))\
			end\
			text, back = stringsub(allCols,tPos,tPos), stringsub(allCols,bPos,bPos)\
			if oldTpos ~= tPos or oldBpos ~= bPos then\
				render()\
			end\
		elseif evt[1] == \"key\" then\
			if evt[2] == keys.enter then\
				for y = 1, ysize do\
					output[1][y] = table.concat(output[1][y])\
					output[2][y] = table.concat(output[2][y])\
					output[3][y] = table.concat(output[3][y])\
					maxWidth  = math.max(maxWidth,  #stringgsub(output[3][y], \" +$\", \"\"))\
					minMargin = math.min(minMargin, output[3][y]:find(\"[^ ]\") or math.huge)\
				end\
				--error(minMargin)\
				local croppedOutput = {}\
				local touched = false\
				local crY = 0\
				for a = 1, ysize do\
					if output[1][1] == (\" \"):rep(xsize) and output[3][1] == (\" \"):rep(xsize) then\
						tableremove(output[1],1)\
						tableremove(output[2],1)\
						tableremove(output[3],1)\
					else\
						for y = #output[1], 1, -1 do\
							if output[1][y] == (\" \"):rep(xsize) and output[3][y] == (\" \"):rep(xsize) then\
								tableremove(output[1],y)\
								tableremove(output[2],y)\
								tableremove(output[3],y)\
							else\
								break\
							end\
						end\
						break\
					end\
				end\
				for y = 1, #output[1] do\
					output[1][y] = output[1][y]:sub(minMargin, maxWidth)\
					output[2][y] = output[2][y]:sub(minMargin, maxWidth)\
					output[3][y] = output[3][y]:sub(minMargin, maxWidth)\
				end\
				return output\
			elseif evt[2] == keys.leftShift then\
				isShiftDown = true\
			elseif evt[2] == keys.left or evt[2] == keys.right then\
				local oldTpos, oldBpos = tPos, bPos\
				if isShiftDown then\
					tPos = mathmax(1, mathmin(16, tPos + (evt[2] == keys.right and 1 or -1)))\
				else\
					bPos = mathmax(1, mathmin(16, bPos + (evt[2] == keys.right and 1 or -1)))\
				end\
				text, back = allCols:sub(tPos,tPos), allCols:sub(bPos,bPos)\
				if oldTpos ~= tPos or oldBpos ~= bPos then\
					render()\
				end\
			end\
		elseif evt[1] == \"key_up\" then\
			if evt[2] == keys.leftShift then\
				isShiftDown = false\
			end\
		elseif evt[1] == \"char\" then\
			if char ~= evt[2] then\
				char = evt[2]\
				render()\
			end\
		end\
	end\
end\
\
-- notifications will only appear if you have plethora's neural connector and overlay glasses on your person\
\
local notif = {}\
notif.alpha = 248\
notif.height = 10\
notif.width = 6\
notif.time = 40\
notif.wrapX = 350\
notif.maxNotifs = 15\
local nList = {}\
local colorTranslate = {\
	[\" \"] = {240, 240, 240},\
	[\"0\"] = {240, 240, 240},\
	[\"1\"] = {242, 178, 51 },\
	[\"2\"] = {229, 127, 216},\
	[\"3\"] = {153, 178, 242},\
	[\"4\"] = {222, 222, 108},\
	[\"5\"] = {127, 204, 25 },\
	[\"6\"] = {242, 178, 204},\
	[\"7\"] = {76,  76,  76 },\
	[\"8\"] = {153, 153, 153},\
	[\"9\"] = {76,  153, 178},\
	[\"a\"] = {178, 102, 229},\
	[\"b\"] = {51,  102, 204},\
	[\"c\"] = {127, 102, 76 },\
	[\"d\"] = {87,  166, 78 },\
	[\"e\"] = {204, 76,  76 },\
	[\"f\"] = {25,  25,  25 }\
}\
local interface, canvas = peripheral.find(\"neuralInterface\")\
if interface then\
	if interface.canvas then\
		canvas = interface.canvas()\
		notif.newNotification = function(char, text, back, time)\
			if #nList > notif.maxNotifs then\
				tableremove(nList, 1)\
			end\
			nList[#nList+1] = {char,text,back,time,1} -- the last one is the alpha multiplier\
		end\
		notif.displayNotifications = function(doCountDown)\
			local adjList = {\
				[\"i\"] = -4,\
				[\"l\"] = -3,\
				[\"I\"] = -1,\
				[\"t\"] = -2,\
				[\"k\"] = -1,\
				[\"!\"] = -4,\
				[\"|\"] = -4,\
				[\".\"] = -4,\
				[\",\"] = -4,\
				[\":\"] = -4,\
				[\";\"] = -4,\
				[\"f\"] = -1,\
				[\"'\"] = -3,\
				[\"\\\"\"] = -1,\
				[\"<\"] = -1,\
				[\">\"] = -1,\
			}\
			local drawEdgeLine = function(y,alpha)\
				local l = canvas.addRectangle(notif.wrapX, 1+(y-1)*notif.height, 1, notif.height)\
				l.setColor(unpack(colorTranslate[\"0\"]))\
				l.setAlpha(alpha / 2)\
			end\
			local getWordWidth = function(str)\
				local output = 0\
				for a = 1, #str do\
					output = output + notif.width + (adjList[stringsub(str,a,a)] or 0)\
				end\
				return output\
			end\
			canvas.clear()\
			local xadj, charadj, wordadj, t, r\
			local x, y, words, txtwords, bgwords = 0, 0\
			for n = 1, mathmin(#nList, notif.maxNotifs) do\
				xadj, charadj = 0, 0\
				y = y + 1\
				x = 0\
				words = explode(\" \",nList[n][1],nil,true)\
				txtwords = explode(\" \",nList[n][1],nList[n][2],true)\
				bgwords = explode(\" \",nList[n][1],nList[n][3],true)\
				local char, text, back\
				local currentX = 0\
				for w = 1, #words do\
					char = words[w]\
					text = txtwords[w]\
					back = bgwords[w]\
					if currentX + getWordWidth(char) > notif.wrapX then\
						y = y + 1\
						x = 2\
						xadj = 0\
						currentX = x * notif.width\
					end\
					for cx = 1, #char do\
						x = x + 1\
						charadj = (adjList[stringsub(char,cx,cx)] or 0)\
						r = canvas.addRectangle(xadj+1+(x-1)*notif.width, 1+(y-1)*notif.height, charadj+notif.width, notif.height)\
						if stringsub(back,cx,cx) ~= \" \" then\
							r.setAlpha(notif.alpha * nList[n][5])\
							r.setColor(unpack(colorTranslate[stringsub(back,cx,cx)]))\
						else\
							r.setAlpha(100 * nList[n][5])\
							r.setColor(unpack(colorTranslate[\"7\"]))\
						end\
						drawEdgeLine(y,notif.alpha * nList[n][5])\
						t = canvas.addText({xadj+1+(x-1)*notif.width,2+(y-1)*notif.height}, stringsub(char,cx,cx))\
						t.setAlpha(notif.alpha * nList[n][5])\
						t.setColor(unpack(colorTranslate[stringsub(text,cx,cx)]))\
						xadj = xadj + charadj\
						currentX = currentX + charadj+notif.width\
					end\
				end\
			end\
			for n = mathmin(#nList, notif.maxNotifs), 1, -1 do\
				if doCountDown then\
					if nList[n][4] > 1 then\
						nList[n][4] = nList[n][4] - 1\
					else\
						if nList[n][5] > 0 then\
							while true do\
								nList[n][5] = mathmax(nList[n][5] - 0.2, 0)\
								notif.displayNotifications(false)\
								if nList[n][5] == 0 then break else sleep(0.05) end\
							end\
						end\
						tableremove(nList,n)\
					end\
				end\
			end\
		end\
	end\
end\
\
local darkerCols = {\
	[\"0\"] = \"8\",\
	[\"1\"] = \"c\",\
	[\"2\"] = \"a\",\
	[\"3\"] = \"b\",\
	[\"4\"] = \"1\",\
	[\"5\"] = \"d\",\
	[\"6\"] = \"2\",\
	[\"7\"] = \"f\",\
	[\"8\"] = \"7\",\
	[\"9\"] = \"b\",\
	[\"a\"] = \"7\",\
	[\"b\"] = \"7\",\
	[\"c\"] = \"f\",\
	[\"d\"] = \"7\",\
	[\"e\"] = \"7\",\
	[\"f\"] = \"f\"\
}\
\
-- used for regular chat. they can be disabled if you hate fun\
local animations = {\
	slideFromLeft = function(char, text, back, frame, maxFrame, length)\
		return {\
			stringsub(char, (length or #char) - ((frame/maxFrame)*(length or #char))),\
			stringsub(text, (length or #text) - ((frame/maxFrame)*(length or #text))),\
			stringsub(back, (length or #back) - ((frame/maxFrame)*(length or #back)))\
		}\
	end,\
	fadeIn = function(char, text, back, frame, maxFrame, length)\
		-- a good example:\
		-- &1what &2in &3the &4world &5are &6you &7doing &8in &9my &aswamp\
		for i = 1, 3 - math.ceil(frame/maxFrame * 3) do\
			text = stringgsub(text, \".\", darkerCols)\
		end\
		return {\
			char,\
			text,\
			back\
		}\
	end,\
	flash = function(char, text, back, frame, maxFrame, length)\
		local t = palette.txt\
		if frame ~= maxFrame then\
			t = (frame % 2 == 0) and t or palette.bg\
		end\
		return {\
			char,\
			toblit[t]:rep(#text),\
			(frame % 2 == 0) and back or (\" \"):rep(#back)\
		}\
	end,\
	none = function(char, text, back, frame, maxFrame, length)\
		return {\
			char,\
			text,\
			back\
		}\
	end\
}\
\
local inAnimate = function(animType, buff, frame, maxFrame, length)\
	local char, text, back = buff[1], buff[2], buff[3]\
	if enchatSettings.doAnimate and (frame >= 0) and (maxFrame > 0) then\
		return animations[animType or \"slideFromleft\"](char, text, back, frame, maxFrame, length)\
	else\
		return {char,text,back}\
	end\
end\
\
local genRenderLog = function()\
	local buff, prebuff, maxLength, lastUser\
	local scrollToBottom = scroll == maxScroll\
	renderlog = {}\
	local dcName, dcMessage\
	for a = 1, #log do\
		if not ((lastUser == log[a].personalID and log[a].personalID) and log[a].name == \"\" and log[a].message == \" \") then\
			termsetCursorPos(1,1)\
			if UIconf.nameDecolor then\
				if lastUser == log[a].personalID and log[a].personalID then\
					dcName = \"\"\
				else\
					dcName = textToBlit(table.concat({log[a].prefix,log[a].name,log[a].suffix}), true, toblit[palette.txt], toblit[palette.bg])\
				end\
				dcMessage = textToBlit(log[a].message, false, toblit[palette.txt], toblit[palette.bg])\
				prebuff = {\
					dcName..dcMessage[1],\
					toblit[palette.chevron]:rep(#dcName)..dcMessage[2],\
					toblit[palette.bg]:rep(#dcName)..dcMessage[3]\
				}\
			else\
				if lastUser == log[a].personalID and log[a].personalID then\
					prebuff = textToBlit(\" \" .. log[a].message, false, toblit[palette.txt], toblit[palette.bg])\
				else\
					prebuff = textToBlit(table.concat({\
						log[a].prefix,\
						\"&}&r~r\",\
						log[a].name,\
						\"&}&r~r\",\
						log[a].suffix,\
						\"&}&r~r\",\
						log[a].message\
					}),\
					false, toblit[palette.txt], toblit[palette.bg])\
				end\
			end\
			if log[a].message ~= \" \" and enchatSettings.noRepeatNames then\
				lastUser = log[a].personalID\
			end\
			if (log[a].frame == 0) and (canvas and enchatSettings.doNotif) then\
				if not (log[a].name == \"\" and log[a].message == \" \") then\
					notif.newNotification(prebuff[1], prebuff[2], prebuff[3], notif.time * 4)\
				end\
			end\
			if log[a].maxFrame == true then\
				log[a].maxFrame = math.floor(mathmin(#prebuff[1], scr_x) / enchatSettings.animDiv)\
			end\
			if log[a].ignoreWrap then\
				buff, maxLength = {prebuff}, mathmin(#prebuff[1], scr_x)\
			else\
				buff, maxLength = blitWrap(prebuff[1], prebuff[2], prebuff[3], true)\
			end\
			-- repeat every line in multiline entries\
			for l = 1, #buff do\
				-- holy shit, two animations, lookit mr. roxas over here\
				if log[a].animType then\
					renderlog[#renderlog + 1] = inAnimate(log[a].animType, buff[l], log[a].frame, log[a].maxFrame, maxLength)\
				else\
					renderlog[#renderlog + 1] = inAnimate(\"fadeIn\", inAnimate(\"slideFromLeft\", buff[l], log[a].frame, log[a].maxFrame, maxLength), log[a].frame, log[a].maxFrame, maxLength)\
				end\
			end\
			if (log[a].frame < log[a].maxFrame) and log[a].frame >= 0 then\
				log[a].frame = log[a].frame + 1\
			else\
				log[a].frame = -1\
			end\
		end\
	end\
	maxScroll = mathmax(0, #renderlog - (scr_y - 2))\
	if scrollToBottom then\
		scroll = maxScroll\
	end\
end\
\
-- there is probably a much better way of doing this, but I don't care at the moment\
local tsv = function(visible)\
	if term.current().setVisible and enchatSettings.useSetVisible then\
		return term.current().setVisible(visible)\
	end\
end\
\
local renderChat = function(doScrollBackUp)\
	tsv(false)\
	termsetCursorBlink(false)\
	genRenderLog(log)\
	local ry\
	termsetBackgroundColor(palette.bg)\
	for y = UIconf.chatlogTop, (scr_y-UIconf.promptY) - 1 do\
		ry = (y + scroll - (UIconf.chatlogTop - 1))\
		termsetCursorPos(1,y)\
		termclearLine()\
		if renderlog[ry] then\
			termblit(unpack(renderlog[ry]))\
		end\
	end\
	if UIconf.promptY ~= 0 then\
		termsetCursorPos(1,scr_y)\
		termsetTextColor(palette.scrollMeter)\
		termclearLine()\
		termwrite(scroll..\" / \"..maxScroll..\"  \")\
	end\
\
	local _title = UIconf.title:gsub(\"YOURNAME\", yourName..\"&}&r~r\"):gsub(\"ENCKEY\", encKey..\"&}&r~r\"):gsub(\"PORT\", tostring(enchat.port))\
	if UIconf.doTitle then\
		termsetTextColor(palette.title)\
		term.setBackgroundColor(palette.titlebg)\
		if UIconf.nameDecolor then\
			if UIconf.centerTitle then\
				cwrite((\" \"):rep(scr_x)..textToBlit(_title, true)..(\" \"):rep(scr_x), UIconf.titleY or 1)\
			else\
				termsetCursorPos(1, UIconf.titleY or 1)\
				termwrite(textToBlit(_title, true)..(\" \"):rep(scr_x))\
			end\
		else\
			local blTitle = textToBlit(_title)\
			termsetCursorPos(UIconf.centerTitle and ((scr_x/2) - math.ceil(#blTitle[1]/2)) or 1, UIconf.titleY or 1)\
			termclearLine()\
			termblit(unpack(blTitle))\
		end\
	end\
	termsetCursorBlink(true)\
	tsv(true)\
end\
\
local logadd = function(name, message, animType, maxFrame, ignoreWrap, _personalID)\
	log[#log + 1] = {\
		prefix = name and UIconf.prefix or \"\",\
		suffix = name and UIconf.suffix or \"\",\
		name = name or \"\",\
		message = message or \" \",\
		ignoreWrap = ignoreWrap,\
		frame = 0,\
		maxFrame = maxFrame or true,\
		animType = animType,\
		personalID = _personalID\
	}\
end\
\
local logaddTable = function(name, message, animType, maxFrame, ignoreWrap, _personalID)\
	if type(message) == \"table\" and type(name) == \"string\" then\
		if #message > 0 then\
			local isGood = true\
			for l = 1, #message do\
				if type(message[l]) ~= \"string\" then\
					isGood = false\
					break\
				end\
			end\
			if isGood then\
				logadd(name, message[1], animType, maxFrame, ignoreWrap, _personalID)\
				for l = 2, #message do\
					logadd(nil, message[l], animType, maxFrame, ignoreWrap, _personalID)\
				end\
			end\
		end\
	end\
end\
\
local enchatSend = function(name, message, option, doLog, animType, maxFrame, crying, recipient, ignoreWrap, omitPersonalID)\
	option = option or {}\
	if option.doLog then\
		if type(message) == \"string\" then\
			logadd(name, message, option.animType, option.maxFrame, option.ignoreWrap, (not option.omitPersonalID) and personalID)\
		else\
			logaddTable(name, message, option.animType, option.maxFrame, option.ignoreWrap, (not option.omitPersonalID) and personalID)\
		end\
	end\
	local messageID = makeRandomString(64)\
	local outmsg = encrite({\
		name = name,\
		message = message,\
		animType = option.animType,\
		maxFrame = option.maxFrame,\
		messageID = messageID,\
		recipient = option.recipient,\
		ignoreWrap = option.ignoreWrap,\
		personalID = (not option.omitPersonalID) and personalID,\
		cry = option.crying,\
		simCommand = option.simCommand,\
		simArgument = option.simArgument,\
	})\
	IDlog[messageID] = true\
	if not enchat.ignoreModem then\
		modemTransmit(enchat.port, enchat.port, outmsg)\
	end\
	if skynet and enchatSettings.useSkynet then\
		skynet.send(enchat.skynetPort, outmsg)\
	end\
end\
\
local cryOut = function(name, crying)\
	enchatSend(name, nil, {crying = crying})\
end\
\
local getPictureFile = function(path) -- ONLY NFP or NFT, fuck BLT\
	if not fs.exists(path) then\
		return false, \"No such image.\"\
	else\
		local file = fs.open(path,\"r\")\
		local content = file.readAll()\
		file.close()\
		local output\
		if content:find(\"\\31\") and content:find(\"\\30\") then\
			output = explode(\"\\n\",content:gsub(\"\\31\",\"&\"):gsub(\"\\30\",\"~\"),nil,false)\
		else\
			if content:lower():gsub(\"[0123456789abcdef\\n ]\",\"\") ~= \"\" then\
				return false, \"Invalid image.\"\
			else\
				output = explode(\"\\n\",content:gsub(\"[^\\n]\",\"~%1 \"),nil,false)\
			end\
		end\
		return output\
	end\
end\
\
local getTableLength = function(tbl)\
	local output = 0\
	for k,v in pairs(tbl) do\
		output = output + 1\
	end\
	return output\
end\
\
local userCryList = {}\
\
local commandInit = \"/\"\
local commands = {}\
local simmableCommands = {\
	big = true\
}\
-- Commands only have one argument, being a single string.\
-- Separate arguments can be extrapolated with the explode() function.\
commands.about = function()\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	logadd(nil,\"Enchat \"..enchat.version..\" by LDDestroier.\")\
	logadd(nil,\"'Encrypted, decentralized, &1c&2o&3l&4o&5r&6i&7z&8e&9d&r chat program'\")\
	logadd(nil,\"Made in 2018, out of gum and procrastination.\")\
	logadd(nil,nil)\
	logadd(nil,\"AES Lua implementation made by SquidDev.\")\
	logadd(nil,\"'Skynet' (enables HTTP chat) belongs to gollark (osmarks).\")\
end\
commands.exit = function()\
	enchatSend(\"*\", \"'\"..yourName..\"&}&r~r' buggered off. (disconnect)\")\
	return \"exit\"\
end\
commands.me = function(msg)\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	if msg then\
		enchatSend(\"&2*\", yourName..\"~r&2 \"..msg, {doLog = true})\
	else\
		logadd(\"*\",commandInit..\"me [message]\")\
	end\
end\
commands.tron = function()\
  local url = \"https://raw.githubusercontent.com/LDDestroier/CC/master/tron.lua\"\
  local prog, contents = http.get(url)\
  if prog then\
    enchatSend(\"*\", yourName .. \"&}&r~r has started a game of TRON.\", {doLog = true})\
    contents = prog.readAll()\
    pauseRendering = true\
    prog = load(contents, nil, nil, _ENV)(enchatSettings.useSkynet and \"skynet\", \"quick\", yourName)\
  else\
    logadd(\"*\", \"Could not download TRON.\")\
  end\
  pauseRendering = false\
  doRender = true\
end\
commands.colors = function()\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	logadd(\"*\", \"&{Color codes: (use & or ~)&}\")\
	logadd(nil, \" &7~11~22~33~44~55~66~7&87~8&78~99~aa~bb~cc~dd~ee~ff\")\
	logadd(nil, \" &{Reset text/BG with &r and ~r.&}\")\
	logadd(nil, \" &{Use &k for krazy text.&}\")\
end\
commands.update = function()\
	local res, message = updateEnchat()\
	if res then\
		enchatSend(\"*\", yourName..\"&}&r~r has updated and exited.\")\
		termsetBackgroundColor(colors.black)\
		termsetTextColor(colors.white)\
		termclear()\
		termsetCursorPos(1,1)\
		print(message)\
		return \"exit\"\
	else\
		logadd(\"*\", res)\
	end\
end\
commands.picto = function(filename)\
	local image, output, res\
	local isEmpty\
	if filename then\
		output, res = getPictureFile(filename)\
		if not output then\
			logadd(\"*\",res)\
			logadd(nil,nil)\
			return\
		else\
			tableinsert(output,1,\"\")\
		end\
	else\
		isEmpty = true\
		output = {\"\"}\
		pauseRendering = true\
		local image = pictochat(26,11)\
		pauseRendering = false\
		for y = 1, #image[1] do\
			output[#output+1] = \"\"\
			for x = 1, #image[1][1] do\
				output[#output] = table.concat({\
					output[#output],\
					\"&\",\
					image[2][y]:sub(x,x),\
					\"~\",\
					image[3][y]:sub(x,x),\
					image[1][y]:sub(x,x)\
				})\
				isEmpty = isEmpty and (image[1][y]:sub(x,x) == \" \" and image[3][y]:sub(x,x) == \" \")\
			end\
		end\
	end\
	if not isEmpty then\
		enchatSend(yourName, output, {doLog = true, animType = \"slideFromLeft\", ignoreWrap = true})\
	end\
end\
commands.list = function()\
	userCryList = {}\
	local tim = os.startTimer(0.5)\
	cryOut(yourName, true)\
	while true do\
		local evt = {os.pullEvent()}\
		if evt[1] == \"timer\" then\
			if evt[2] == tim then\
				break\
			end\
		end\
	end\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	if getTableLength(userCryList) == 0 then\
		logadd(nil,\"Nobody's there.\")\
	else\
		for k,v in pairs(userCryList) do\
			logadd(nil,\"+'\"..k..\"'\")\
		end\
	end\
end\
commands.nick = function(newName)\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	if newName then\
		if checkValidName(newName) then\
			if newName == yourName then\
				logadd(\"*\",\"But you're already called that!\")\
			else\
				enchatSend(\"*\", \"'\"..yourName..\"&}&r~r' is now known as '\"..newName..\"&}&r~r'.\", {doLog = true})\
				yourName = newName\
			end\
		else\
			if #newName < 2 then\
				logadd(\"*\", \"That name is too damned small.\")\
			elseif #newName > 32 then\
				logadd(\"*\", \"Woah there, that name is too large.\")\
			end\
		end\
	else\
		logadd(\"*\",commandInit..\"nick [newName]\")\
	end\
end\
commands.whoami = function(now)\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	if now == \"now\" then\
		logadd(\"*\",\"You are still '\"..yourName..\"&}&r~r'!\")\
	else\
		logadd(\"*\",\"You are '\"..yourName..\"&}&r~r'!\")\
	end\
end\
commands.key = function(newKey)\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	if newKey then\
		if newKey ~= encKey then\
			enchatSend(\"*\", \"'\"..yourName..\"&}&r~r' buggered off. (keychange)\")\
			setEncKey(newKey)\
			logadd(\"*\", \"Key changed to '\"..encKey..\"&}&r~r'.\")\
			enchatSend(\"*\", \"'\"..yourName..\"&}&r~r' has moseyed on over.\", {omitPersonalID = true})\
		else\
			logadd(\"*\", \"That's already the key, though.\")\
		end\
	else\
		logadd(\"*\",\"Key = '\"..encKey..\"&}&r~r'\")\
		logadd(\"*\",\"Channel = '\"..enchat.port..\"'\")\
	end\
end\
commands.shrug = function(face)\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	enchatSend(yourName, \"\\\\_\"..(face and (\"(\"..face..\")\") or \"\\2\")..\"_/\", {doLog = true})\
end\
commands.asay = function(_argument)\
	local sPoint = (_argument or \"\"):find(\" \")\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	if not sPoint then\
		logadd(\"*\",\"Animation types:\")\
		for k,v in pairs(animations) do\
			logadd(nil,\" '\"..k..\"'\")\
		end\
	else\
		local animType = _argument:sub(1,sPoint-1)\
		local message = _argument:sub(sPoint+1)\
		local animFrameMod = {\
			flash = 8,\
			fadeIn = 4,\
		}\
		if animations[animType] then\
			if textToBlit(message,true):gsub(\" \",\"\") ~= \"\" then\
				enchatSend(yourName, message, {doLog = true, animType = animType, maxFrame = animFrameMod[animType]})\
			else\
				logadd(\"*\",\"That message is no good.\")\
			end\
		else\
			logadd(\"*\",\"Invalid animation type.\")\
		end\
	end\
end\
commands.big = function(_argument, simUser)\
	local sPoint = (_argument or \"\"):find(\" \")\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	if not sPoint then\
		logadd(\"*\",commandInit .. \"big <size> <text>\")\
	else\
		local fontSize = tonumber(_argument:sub(1,sPoint-1))\
		local message = _argument:sub(sPoint+1)\
		if not fontSize then\
			logadd(\"*\",\"Size must be number between 0 and 2.\")\
		elseif fontSize < 0 or fontSize > 2 then\
			logadd(\"*\",\"Size must be number between 0 and 2.\")\
		else\
			fontSize = math.floor(.5+fontSize)\
			local tOutput\
			if fontSize > 0 then\
				message = textToBlit(message, false, \"0\", \"f\")\
				local output = {{},{},{}}\
				local x, y = 1, 1\
				local char\
				for i = 1, #message[1] do\
					char = bigfont.makeBlittleText(\
						fontSize,\
						stringsub(message[1],i,i),\
						stringsub(message[2],i,i),\
						stringsub(message[3],i,i)\
					)\
					x = x + char.width\
					if x >= scr_x then\
						y = y + char.height\
						x = char.width\
					end\
					for charY = 1, char.height do\
						output[1][y+charY-1] = (output[1][y+charY-1] or \" \") .. char[1][charY]\
						output[2][y+charY-1] = (output[2][y+charY-1] or \" \") .. char[2][charY]\
						output[3][y+charY-1] = (output[3][y+charY-1] or \" \") .. char[3][charY]\
					end\
				end\
				tOutput = {\"\"}\
				local yy = 1\
				for y = 1, #output[1] do\
					tOutput[#tOutput+1] = \"\"\
					for x = 1, #output[1][y] do\
						tOutput[#tOutput] = table.concat({tOutput[#tOutput],\"&\",output[2][yy]:sub(x,x),\"~\",output[3][yy]:sub(x,x),output[1][yy]:sub(x,x)})\
					end\
					yy = yy + 1\
				end\
			else\
				tOutput = message\
			end\
			if simUser then\
				logaddTable(simUser, tOutput)\
			else\
				logaddTable(yourName, tOutput)\
				enchatSend(yourName, nil, {simCommand = \"big\", simArgument = _argument})\
			end\
		end\
	end\
end\
commands.msg = function(_argument)\
	local sPoint = (_argument or \"\"):find(\" \")\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	if not sPoint then\
		logadd(\"*\",commandInit..\"msg <recipient> <message>\")\
	else\
		local recipient = _argument:sub(1,sPoint-1)\
                local message = _argument:sub(sPoint+1)\
		if not message then\
			logadd(\"*\",\"You got half of the arguments down pat, at least.\")\
		else\
			if textToBlit(message,true):gsub(\" \",\"\") == \"\" then\
				logadd(\"*\",\"That message is no good.\")\
			else\
				enchatSend(yourName, message, {recipient = recipient})\
				logadd(\"*\",\"to '\"..recipient..\"': \"..message)\
			end\
		end\
	end\
end\
commands.palette = function(_argument)\
	local argument = _argument or \"\"\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	if argument:gsub(\"%s\",\"\") == \"\" then\
		local buff = \"\"\
		for k,v in pairs(palette) do\
			buff = buff..k..\", \"\
		end\
		buff = buff:sub(1,-3)\
		logadd(\"*\",commandInit..\"palette \"..buff..\" <colorcode>\")\
	else\
		argument = explode(\" \",argument)\
		if #argument == 1 then\
			if argument[1]:gsub(\"%s\",\"\"):lower() == \"reset\" or argument[1]:gsub(\"%s\",\"\"):lower() == \"enchat3\" then\
				palette = {\
					bg = colors.black,\
					txt = colors.white,\
					promptbg = colors.gray,\
					prompttxt = colors.white,\
					scrollMeter = colors.lightGray,\
					chevron = colors.black,\
					title = colors.lightGray,\
					titlebg = colors.gray,\
				}\
				UIconf = {\
					promptY = 1,\
					chevron = \">\",\
					chatlogTop = 1,\
					title = \"Enchat 3\",\
					doTitle = false,\
					titleY = 1,\
					nameDecolor = false,\
					centerTitle = true,\
					prefix = \"<\",\
					suffix = \"> \"\
				}\
				termsetBackgroundColor(palette.bg)\
				termclear()\
				logadd(\"*\",\"You cleansed your palette.\")\
				saveSettings()\
			elseif argument[1]:gsub(\"%s\",\"\"):lower() == \"enchat2\" then\
				palette = {\
					bg = colors.gray,\
					txt = colors.white,\
					promptbg = colors.white,\
					prompttxt = colors.black,\
					scrollMeter = colors.white,\
					chevron = colors.lightGray,\
					title = colors.yellow,\
					titlebg = colors.gray,\
				}\
				UIconf = {\
					promptY = 1,\
					chevron = \">\",\
					chatlogTop = 1,\
					title = \"Enchat 2\",\
					doTitle = false,\
					titleY = 1,\
					nameDecolor = false,\
					centerTitle = false,\
					prefix = \"<\",\
					suffix = \"> \"\
				}\
				termsetBackgroundColor(palette.bg)\
				termclear()\
				logadd(\"*\",\"Switched to the old Enchat2 palette.\")\
				saveSettings()\
			elseif argument[1]:gsub(\"%s\",\"\"):lower() == \"enchat1\" then\
				logadd(\"*\",\"We don't talk about that one.\")\
			elseif argument[1]:gsub(\"%s\",\"\"):lower() == \"enchat4\" then\
				logadd(\"*\",\"Let's leave that to future LDD.\")\
			elseif argument[1]:gsub(\"%s\",\"\"):lower() == \"chat.lua\" then\
				palette = {\
					bg = colors.black,\
					txt = colors.white,\
					promptbg = colors.black,\
					prompttxt = colors.white,\
					scrollMeter = colors.white,\
					chevron = colors.yellow,\
					title = colors.yellow,\
					titlebg = colors.black,\
				}\
				UIconf = {\
					promptY = 0,\
					chevron = \": \",\
					chatlogTop = 2,\
					title = \"YOURNAME on ENCKEY\",\
					doTitle = true,\
					titleY = 1,\
					nameDecolor = true,\
					centerTitle = true,\
					prefix = \"<\",\
					suffix = \"> \"\
				}\
				termsetBackgroundColor(palette.bg)\
				termclear()\
				logadd(\"*\",\"Switched to /rom/programs/rednet/chat.lua palette.\")\
				saveSettings()\
			elseif argument[1]:gsub(\"%s\",\"\"):lower() == \"talk\" then\
				palette = {\
					bg = colors.black,\
					txt = colors.white,\
					promptbg = colors.black,\
					prompttxt = colors.white,\
					scrollMeter = colors.white,\
					chevron = colors.white,\
					title = colors.black,\
					titlebg = colors.white,\
				}\
				UIconf = {\
					promptY = 0,\
					chevron = \"\",\
					chatlogTop = 1,\
					title = \" enchat v3.0     channel: ENCKEY:PORT\",\
					titleY = scr_y - 1,\
					doTitle = true,\
					nameDecolor = false,\
					centerTitle = false,\
					prefix = \"<\",\
					suffix = \"> \"\
				}\
				termsetBackgroundColor(palette.bg)\
				termclear()\
				logadd(\"*\",\"Switched to Talk palette.\")\
				saveSettings()\
			elseif argument[1]:gsub(\"%s\",\"\"):lower() == \"darkchat\" then\
				palette = {\
					bg = colors.black,\
					txt = colors.white,\
					promptbg = colors.black,\
					prompttxt = colors.white,\
					scrollMeter = colors.white,\
					chevron = colors.white,\
					title = colors.white,\
					titlebg = colors.blue,\
				}\
				UIconf = {\
					promptY = 0,\
					chevron = \"Message: \",\
					chatlogTop = 1,\
					title = \"<User: YOURNAME> <Channel: ENCKEY>\",\
					titleY = scr_y - 1,\
					doTitle = true,\
					nameDecolor = false,\
					centerTitle = true,\
					prefix = \"\",\
					suffix = \": \"\
				}\
				termsetBackgroundColor(palette.bg)\
				termclear()\
				logadd(\"*\",\"Switched to DarkChat palette.\")\
				saveSettings()\
			else\
				if not palette[argument[1]] then\
					logadd(\"*\",\"There's no such palette option.\")\
				else\
					logadd(\"*\",\"'\"..argument[1]..\"' = '\"..toblit[palette[argument[1]]]..\"'\")\
				end\
			end\
		else\
			if #argument > 2 then\
				argument = {argument[1], table.concat(argument,\" \",2)}\
			end\
			argument[1] = argument[1]:lower()\
			local newcol = argument[2]:lower()\
			if not palette[argument[1]] then\
				logadd(\"*\",\"That's not a valid palette choice.\")\
			else\
				if not (tocolors[newcol] or colors_strnames[newcol]) then\
					logadd(\"*\",\"That isn't a valid color code. (0-f)\")\
				else\
					palette[argument[1]] = (tocolors[newcol] or colors_strnames[newcol])\
					logadd(\"*\",\"Palette changed.\",false)\
					saveSettings()\
				end\
			end\
		end\
	end\
end\
commands.clear = function()\
	log = {}\
	IDlog = {}\
end\
commands.ping = function(pong)\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	logadd(nil, pong or \"Pong!\")\
end\
commands.set = function(_argument)\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	argument = _argument or \"\"\
	local collist = {\
		[\"string\"] = function() return \"0\" end,\
		[\"table\"] = function() return \"5\" end,\
		[\"number\"] = function() return \"0\" end,\
		[\"boolean\"] = function(val) if val then return \"d\" else return \"e\" end end,\
		[\"function\"] = function() return \"c\" end,\
		[\"nil\"] = function() return \"8\" end,\
		[\"thread\"] = function() return \"d\" end,\
		[\"userdata\"] = function() return \"c\" end, -- ha\
	}\
	local custColorize = function(input)\
		return \"&\"..collist[type(input)](input)\
	end\
	local contextualQuote = function(judgetxt,txt)\
		if type(judgetxt) == \"string\" then\
			return table.concat({\"'\",txt,\"'\"})\
		else\
			return txt\
		end\
	end\
	local arguments = explode(\" \",argument)\
	if #argument == 0 then\
		for k,v in pairs(enchatSettings) do\
			logadd(nil,\"&4'\"..k..\"'&r = \"..contextualQuote(v,custColorize(v)..tostring(v)..\"&r\"))\
		end\
	else\
		if enchatSettings[arguments[1]] ~= nil then\
			if #arguments >= 2 then\
				local newval = table.concat(arguments,\" \",2)\
				if tonumber(newval) then\
					newval = tonumber(newval)\
				elseif textutilsunserialize(newval) ~= nil then\
					newval = textutilsunserialize(newval)\
				end\
				if type(enchatSettings[arguments[1]]) == type(newval) then\
					enchatSettings[arguments[1]] = newval\
					logadd(\"*\",\"Set '&4\"..arguments[1]..\"&r' to &{\"..contextualQuote(newval,textutilsserialize(newval)..\"&}\")..\" (\"..type(newval)..\")\")\
					saveSettings()\
				else\
					logadd(\"*\",\"Wrong value type (it's \"..type(enchatSettings[arguments[1]])..\")\")\
				end\
			else\
				logadd(\"*\",\"'\"..arguments[1]..\"' is set to \"..contextualQuote(enchatSettings[arguments[1]],custColorize(enchatSettings[arguments[1]])..textutilsserialize(enchatSettings[arguments[1]])..\"&r\")..\" (\"..type(enchatSettings[arguments[1]])..\")\")\
			end\
		else\
			logadd(\"*\",\"No such setting.\")\
		end\
	end\
	if enchatSettings.useSkynet and (not skynet) then\
		pauseRendering = true\
		termsetBackgroundColor(colors.black)\
		termclear()\
		pauseRendering = false\
	end\
end\
commands.help = function(cmdname)\
	if enchatSettings.extraNewline then\
		logadd(nil,nil)\
	end\
	if cmdname then\
		local helpList = {\
			exit = \"Exits Enchat and returns to loader (most likely CraftOS)\",\
			about = \"Tells you a bit about this here Enchat.\",\
			me = \"Sends a message in the format of \\\"* yourName message\\\"\",\
			colors = \"Lists all the colors you can use.\",\
			update = \"Updates and overwrites Enchat, then exits if successful.\",\
			list = \"Lists all users in range using the same key.\",\
			nick = \"Give yourself a different username.\",\
			whoami = \"Tells you your current username.\",\
			key = \"Change the current encryption key. Tells you the key, if without argument.\",\
			clear = \"Clears the local chat log. Not your inventory, I swear.\",\
			ping = \"Pong. *sigh*\",\
			shrug = \"Sends out a shrugging emoticon.\",\
			set = \"Changes config options during the current session. Lists all options, if without argument.\",\
			msg = \"Sends a message that is only logged by a specific user.\",\
			picto = \"Opens an image maker and sends the result. Use the scroll wheel to change color, and hold left shift to change text color. If argument given, will look for an image at the given path and use that instead.\",\
			tron = \"Starts up a game of TRON.\",\
			big = \"Sends your message, but enlarged by a specified amount via Wojbie's BigFont API.\",\
			help = \"Shows every command, or describes a specific command.\",\
		}\
		cmdname = cmdname:gsub(\" \",\"\"):gsub(\"/\",\"\")\
		if helpList[cmdname] then\
			logadd(\"*\", helpList[cmdname])\
		else\
			if commands[cmdname] then\
				logadd(\"*\", \"No help info for that command.\")\
			else\
				logadd(\"*\", \"No such command to get help for.\")\
			end\
		end\
	else\
		logadd(\"*\",\"All commands:\")\
		local output = \"\"\
		for k,v in pairs(commands) do\
			output = output..\" \"..commandInit..k..\",\"\
		end\
		logadd(nil, output:sub(1,-2))\
	end\
end\
commandAliases = {\
	quit = commands.exit,\
	colours = commands.colors,\
	ls = commands.list,\
	cry = commands.list,\
	nickname = commands.nick,\
	channel = commands.key,\
	palate = commands.palette,\
	tell = commands.msg,\
	whisper = commands.msg,\
	[\"?\"] = commands.help,\
	porn = function() 	logadd(\"*\",\"Yeah, no.\") end,\
	whoareyou = function() 	logadd(\"*\", \"I'm Enchat. But surely, you know this?\") end,\
	fuck = function() 	logadd(\"*\",\"A mind is a terrible thing to waste.\") end,\
	hello = function() 	logadd(\"*\",\"Hey.\") end,\
	hi = function() 	logadd(\"*\",\"Hiya.\") end,\
	hey = function() 	logadd(\"*\",\"That's for horses.\") end,\
	bye = function() 	logadd(\"*\",\"You know, you can use /exit.\") end,\
	die = function() 	logadd(\"*\",\"You wish.\") end,\
	nap = function() 	logadd(\"*\",\"The time for napping has passed.\") end,\
	sorry = function() 	logadd(\"*\",\"That's okay.\") end,\
	jump = function() 	logadd(\"*\",\"Sorry. This program is in a NO JUMPING zone.\") end,\
	enchat = function() 	logadd(\"*\",\"At your service!\") end,\
	win = function() 	logadd(\"*\",\"Naturally!\") end,\
	lose = function() 	logadd(\"*\",\"Preposterous!\") end,\
	xyzzy = function() 	logadd(\"*\",\"A hollow voice says \\\"Fool.\\\"\") end,\
	wait = function() 	logadd(\"*\",\"Time passes...\") end,\
	stop = function() 	logadd(\"*\",\"Hammertime!\",\"fadeIn\") end,\
	shit = function() 	logadd(\"*\",\"Man, you're telling me!\") end,\
	eat = function() 	logadd(\"*\",\"You're not hungry.\") end,\
	what = function() 	logadd(\"*\",\"What indeed.\") end,\
	ldd = function()	logadd(nil,\"& that's me\") end,\
	OrElseYouWill = function()\
		enchatSend(\"*\", \"'\"..yourName..\"&}&r~r' buggered off. (disconnect)\")\
		error(\"DIE\")\
	end\
}\
\
local checkIfCommand = function(input)\
	if input:sub(1,#commandInit) == commandInit then\
		return true\
	else\
		return false\
	end\
end\
\
local parseCommand = function(input)\
	local sPos1, sPos2 = input:find(\" \")\
	local cmdName, cmdArgs\
	if sPos1 then\
		cmdName = input:sub(#commandInit+1, sPos1-1)\
		cmdArgs = input:sub(sPos2+1)\
	else\
		cmdName = input:sub(#commandInit+1)\
		cmdArgs = nil\
	end\
\
	local res\
	local CMD = commands[cmdName] or commandAliases[cmdName]\
	if CMD then\
		res = CMD(cmdArgs)\
		if res == \"exit\" then\
			return \"exit\"\
		end\
	else\
		logadd(\"*\", \"No such command.\")\
	end\
end\
\
local main = function()\
	termsetBackgroundColor(palette.bg)\
	termclear()\
	os.queueEvent(\"render_enchat\")\
	local mHistory = {}\
\
	while true do\
\
		termsetCursorPos(1, scr_y-UIconf.promptY)\
		termsetBackgroundColor(palette.promptbg)\
		termclearLine()\
		termsetTextColor(palette.chevron)\
		termwrite(UIconf.chevron)\
		termsetTextColor(palette.prompttxt)\
\
		local input = colorRead(nil, mHistory)\
		if textToBlit(input,true):gsub(\" \",\"\") ~= \"\" then -- people who send blank messages in chat programs deserve to die\
			if checkIfCommand(input) then\
				local res = parseCommand(input)\
				if res == \"exit\" then\
					return \"exit\"\
				end\
			else\
				if enchatSettings.extraNewline then\
					logadd(nil,nil,nil,nil,nil,personalID) -- readability is key\
				end\
				enchatSend(yourName, input, {doLog = true})\
			end\
			if mHistory[#mHistory] ~= input then\
				mHistory[#mHistory+1] = input\
			end\
		elseif input == \"\" then\
			logadd(nil,nil,nil,nil,nil,personalID)\
		end\
		os.queueEvent(\"render_enchat\")\
\
	end\
\
end\
\
local handleReceiveMessage = function(user, message, animType, maxFrame, _personalID)\
	if enchatSettings.extraNewline then\
		logadd(nil,nil,nil,nil,nil,_personalID) -- readability is still key\
	end\
	logadd(user, message, animations[animType] and animType or nil, (type(maxFrame) == \"number\") and maxFrame or nil, nil, _personalID)\
	os.queueEvent(\"render_enchat\")\
end\
\
local adjScroll = function(distance)\
	scroll = mathmin(maxScroll, mathmax(0, scroll + distance))\
end\
\
local checkRSinput = function()\
	return (\
		rs.getInput(\"front\") or\
		rs.getInput(\"back\")  or\
		rs.getInput(\"left\")  or\
		rs.getInput(\"right\") or\
		rs.getInput(\"top\")   or\
		rs.getInput(\"bottom\")\
	)\
end\
\
local handleEvents = function()\
	local oldScroll\
	local keysDown = {}\
	while true do\
		local evt = {os.pullEvent()}\
		if evt[1] == \"enchat_receive\" then\
			if type(evt[2]) == \"string\" and type(evt[3]) == \"string\" then\
				handleReceiveMessage(evt[2], evt[3])\
			end\
		elseif evt[1] == \"chat\" and ((not checkRSinput()) or (not enchat.disableChatboxWithRedstone)) then\
			if enchat.useChatbox then\
				if enchatSettings.extraNewline then\
					logadd(nil,nil) -- readability is key\
				end\
				enchatSend(evt[2], evt[3], {doLog = true})\
			end\
		elseif evt[1] == \"chat_message\" and ((not checkRSinput()) or (not enchat.disableChatboxWithRedstone)) then -- computronics\
			if enchat.useChatbox then\
				if enchatSettings.extraNewline then\
					logadd(nil,nil) -- readability is key\
				end\
				enchatSend(evt[3], evt[4], {doLog = true})\
			end\
		elseif (evt[1] == \"modem_message\") or (evt[1] == \"skynet_message\" and enchatSettings.useSkynet) then\
			local side, freq, repfreq, msg, distance\
			if evt[1] == \"modem_message\" then\
				side, freq, repfreq, msg, distance = evt[2], evt[3], evt[4], evt[5], evt[6]\
			else\
				freq, msg = evt[2], evt[3]\
			end\
			if (freq == enchat.port) or (freq == enchat.skynetPort) then\
				msg = decrite(msg)\
				if type(msg) == \"table\" then\
					if (type(msg.name) == \"string\") then\
						if #msg.name <= 32 then\
							if msg.messageID and (not IDlog[msg.messageID]) then\
								userCryList[msg.name] = true\
								IDlog[msg.messageID] = true\
								if ((not msg.recipient) or (msg.recipient == yourName or msg.recipient == textToBlit(yourName,true))) then\
									if type(msg.message) == \"string\" then\
										handleReceiveMessage(msg.name, tostring(msg.message), msg.animType, msg.maxFrame, msg.personalID)\
										if chatbox and enchat.useChatbox and ((not checkRSinput()) or (not enchat.disableChatboxWithRedstone)) then\
											chatbox.say(UIconf.prefix .. msg.name .. UIconf.suffix .. msg.message, msg.name)\
										end\
									elseif type(msg.message) == \"table\" and enchatSettings.acceptPictoChat and #msg.message <= 64 then\
										logaddTable(msg.name, msg.message, msg.animType, msg.maxFrame, msg.ignoreWrap, msg.personalID)\
										if enchatSettings.extraNewline then\
											logadd(nil,nil)\
										end\
									elseif commands[msg.simCommand or false] and type(msg.simArgument) == \"string\" then\
										if simmableCommands[msg.simCommand or false] then\
											commands[msg.simCommand](msg.simArgument, msg.name)\
										end\
									end\
								end\
								if (msg.cry == true) then\
									cryOut(yourName, false)\
								end\
							end\
						end\
					end\
				end\
			end\
		elseif evt[1] == \"mouse_scroll\" and (not pauseRendering) then\
			local dist = evt[2]\
			oldScroll = scroll\
			adjScroll(enchatSettings.reverseScroll and -dist or dist)\
			if scroll ~= oldScroll then\
				dab(renderChat)\
			end\
		elseif evt[1] == \"key\" and (not pauseRendering) then\
			local key = evt[2]\
			keysDown[key] = true\
			oldScroll = scroll\
			local pageSize = (scr_y-UIconf.promptY) - UIconf.chatlogTop\
			if key == keys.pageUp then\
				adjScroll(-(keysDown[keys.leftCtrl] and pageSize or enchatSettings.pageKeySpeed))\
			elseif key == keys.pageDown then\
				adjScroll(keysDown[keys.leftCtrl] and pageSize or enchatSettings.pageKeySpeed)\
			end\
			if scroll ~= oldScroll then\
				dab(renderChat)\
			end\
		elseif evt[1] == \"key_up\" then\
			local key = evt[2]\
			keysDown[key] = nil\
		elseif (evt[1] == \"render_enchat\") and (not pauseRendering) then\
			dab(renderChat)\
		elseif (evt[1] == \"tron_complete\") then\
			if evt[3] then\
				if enchatSettings.extraNewline then\
					logadd(nil,nil)\
				end\
				if evt[2] == \"win\" then\
					enchatSend(\"*\", yourName .. \"&}&r~r beat \" .. (evt[4] or \"someone\") .. \"&}&r~r in TRON!\", {doLog = true})\
				elseif evt[2] == \"lose\" then\
					enchatSend(\"*\", (evt[4] or \"Someone\") .. \"&}&r~r beat \" .. yourName .. \"&}&r~r in TRON!\", {doLog = true})\
				elseif evt[2] == \"tie\" then\
					enchatSend(\"*\", yourName .. \"&}&r~r tied with \" .. (evt[4] or \"someone\") .. \"&}&r~r in TRON!\", {doLog = true})\
				end\
			elseif evt[2] == \"timeout\" then\
				if enchatSettings.extraNewline then\
					logadd(nil,nil)\
				end\
				enchatSend(\"*\", yourName .. \"&}&r~r timed out against \" .. (evt[4] or \"someone\") .. \"&}&r~r in TRON...\", {doLog = true})\
			end\
		elseif evt[1] == \"terminate\" then\
			return \"exit\"\
		end\
	end\
end\
\
local keepRedrawing = function()\
	while true do\
		sleep(enchatSettings.redrawDelay)\
		if not pauseRendering then\
			os.queueEvent(\"render_enchat\")\
		end\
	end\
end\
\
local handleNotifications = function()\
	while true do\
		os.pullEvent(\"render_enchat\")\
		if canvas and enchatSettings.doNotif then\
			notif.displayNotifications(true)\
		end\
	end\
end\
\
getModem()\
\
enchatSend(\"*\", \"'\"..yourName..\"&}&r~r' has moseyed on over.\", {doLog = true, omitPersonalID = true})\
\
local funky = {\
	main,\
	handleEvents,\
	keepRedrawing,\
	handleNotifications\
}\
\
if skynet then\
	funky[#funky+1] = function()\
		while true do\
			if skynet then\
				pcall(skynet.listen)\
				local success, msg = pcall(skynet.open, enchat.skynetPort)\
                        	if not success then\
                        		skynet = nil\
				end\
			end\
			sleep(5)\
		end\
	end\
end\
\
pauseRendering = false\
\
local res, outcome = pcall(function()\
	return parallel.waitForAny(unpack(funky))\
end)\
\
os.pullEvent = oldePullEvent\
if skynet then\
	if skynet.socket then\
		skynet.socket.close()\
	end\
end\
\
if canvas then\
	canvas.clear()\
end\
\
tsv(true) -- in case it's false, y'know\
\
if not res then\
	prettyClearScreen(1,scr_y-1)\
	termsetTextColor(colors.white)\
	termsetBackgroundColor(colors.gray)\
	cwrite(\"There was an error.\",2)\
	cfwrite(\"Report this to &3@LDDestroier#2901&r\",3)\
	cwrite(\"on Discord,\",4)\
	cwrite(\"if you feel like it.\",5)\
	termsetCursorPos(1,7)\
	printError(outcome)\
	termsetTextColor(colors.lightGray)\
	cwrite(\"I'll probably fix it, maybe.\",10)\
end\
\
termsetCursorPos(1, scr_y)\
termsetBackgroundColor(initcolors.bg)\
termsetTextColor(initcolors.txt)\
termclearLine()",
    [ "sys/apps/Lattix" ] = "local tArgs = { ... }\
\
\
--[[\
    Release version of Lattix, Version:\
	]]\
local version = \"a0.3\"\
--[[\
    A lot of features from Lattice weren't adopted yet :/ but at least you can enjoy the extra stability\
   \
    Made by Konlab\
   \
    If you wonder why the screen is so stable (no flickering) then it's because of the awesomeness of CrazedProgrammmer's Surface API, go check it out here: http://www.computercraft.info/forums2/index.php?/topic/22397-surface-api-162/\
\
	Big thanks to:\
	EveryOS (thanks for pointing out the command thing)\
]]\
\
\
--CONFIG\
--colors of lattix\
local lat_theme = {\
	menu_back = colors.red;\
	menu_text = colors.white; \
	main_back = colors.white;\
	main_text = colors.black;\
	selected_text = colors.cyan;\
	dir_text = colors.lime;\
	multiselect_back = colors.lightGray;\
	blank_back = colors.white;\
	blank_text = colors.black;\
}\
--colors of lattix on basic comps\
local lat_basic_theme = {\
	menu_back = colors.gray;\
	menu_text = colors.white; \
	main_back = colors.white;\
	main_text = colors.black;\
	selected_text = colors.lightGray;\
	dir_text = colors.black;\
	multiselect_back = colors.white;\
	blank_back = colors.white;\
	blank_text = colors.black;\
}\
local dirprefix = \"\" --this text gets added before dirs\
local basic_dirprefix = \"[] \" --this text gets added before dirs on non-advanced computers\
local selectprefix = \"\" --this text gets added before selected things (even in multiselect)\
local basic_selectprefix = \"> \" --this text gets added before selected things (even in multiselect) on non-advanced computers\
--which programs to use to open .<xtension> files. Special codes: \"run\" and \"api\" and special extension \"def\" - def will be used for every extension not listed (def must be something), run runs it without args, api loads it with os.loadAPI (yes ikr very useful rn since os.loadAPI doesn't like weird extensions). The empty string indicates no extension\
--the file is opened by running the program chosen below with arg #1 being the path to the file\
local defaultPrograms = {\
	[\"\"] = \"/rom/programs/edit.lua\",\
	[\"txt\"] = \"/rom/programs/edit.lua\",\
	[\"cfg\"] = \"/rom/programs/edit.lua\",\
	[\"config\"] = \"/rom/programs/edit.lua\",\
	[\"nfp\"] = \"/rom/programs/fun/advanced/paint.lua\",\
	[\"lua\"] = \"run\",\
--	[\"api\"] = \"api\", --if a custom OS sets up os.loadAPI to work with .api and stores its apis in .api then this could work\
	[\"def\"] = \"/rom/programs/edit.lua\"\
}\
--which programs can be used to create files (think clicking the New... button) Special code: choose means the program is chosen manually through a dialog\
--these programs are run with the path to the file that is to be created as first argument\
local editors = {\
	[\"Other\"] = \"choose\",\
	[\"NFP painting\"] = \"/rom/programs/fun/advanced/paint.lua\",\
	[\"Lua script\"] = \"/rom/programs/edit.lua\",\
	[\"Text file\"] = \"/rom/programs/edit.lua\"\
	\
	\
	\
}\
--Extensions for the above editors\
local editors_extensions = {\
	[\"NFP painting\"] = \"nfp\",\
	[\"Lua script\"] = \"lua\",\
	[\"Text file\"] = \"txt\"\
	\
	\
}\
--paths and links to apis/third party software\
local surfacepath = \"surface\"\
\
--code adopted and modified from CC's source code\
local function pastebinGet(paste, path)\
	\
	if not http then\
		error(\"HTTP disabled\", 2)\
	end\
	--- Attempts to guess the pastebin ID from the given code or URL\
	local extractId = function (paste)\
		local patterns = {\
			\"^([%a%d]+)$\",\
			\"^https?://pastebin.com/([%a%d]+)$\",\
			\"^pastebin.com/([%a%d]+)$\",\
			\"^https?://pastebin.com/raw/([%a%d]+)$\",\
			\"^pastebin.com/raw/([%a%d]+)$\",\
		}\
\
		for i = 1, #patterns do\
			local code = paste:match( patterns[i] )\
			if code then return code end\
		end\
\
		return nil\
	end\
\
	local get = function (url)\
		local paste = extractId( url )\
		if not paste then\
			error( \"Invalid pastebin code.\", 0 )\
			return\
		end\
\
		-- Add a cache buster so that spam protection is re-checked\
		local cacheBuster = (\"%x\"):format(math.random(0, 2^30))\
		local response, err = http.get(\
			\"https://pastebin.com/raw/\"..textutils.urlEncode( paste )..\"?cb=\"..cacheBuster\
		)\
\
		if response then\
			-- If spam protection is activated, we get redirected to /paste with Content-Type: text/html\
			local headers = response.getResponseHeaders()\
			if not headers[\"Content-Type\"] or not headers[\"Content-Type\"]:find( \"^text/plain\" ) then\
				error( \"Pastebin blocked the download due to spam protection. Please complete the captcha in a web browser: https://pastebin.com/\" .. textutils.urlEncode( paste ) , 0)\
				return\
			end\
\
			local sResponse = response.readAll()\
			response.close()\
			return sResponse\
		else\
			error (err, 0)\
		end\
	end\
\
	-- Determine file to download\
	local sCode = paste\
	local sPath = path\
	if fs.exists( sPath ) then\
		error( \"File already exists\", 0 )\
		return\
	end\
\
	-- GET the contents from pastebin\
	local res = get(sCode)\
	if res then\
		local file = fs.open( sPath, \"w\" )\
		file.write( res )\
		file.close()\
	end\
end\
local function wGet(url, sPath)\
\
	if not http then\
		error( \"HTTP disabled\", 2 )\
	end\
\
	local function getFilename( sUrl )\
		sUrl = sUrl:gsub( \"[#?].*\" , \"\" ):gsub( \"/+$\" , \"\" )\
		return sUrl:match( \"/([^/]+)$\" )\
	end\
\
	local function get( sUrl )\
		-- Check if the URL is valid\
		local ok, err = http.checkURL( url )\
		if not ok then\
			error( err or \"Invalid URL.\", 0 )\
			return\
		end\
\
		local response = http.get( sUrl , nil , true )\
		if not response then\
			error( \"Failed.\" )\
		end\
\
		local sResponse = response.readAll()\
		response.close()\
		return sResponse\
	end\
\
	if fs.exists( sPath ) then\
		error( \"File already exists\", 0 )\
		return\
	end\
\
	local res = get(url)\
	if not res then return end\
\
	local file = fs.open( sPath, \"wb\" )\
	file.write( res )\
	file.close()\
end\
\
\
local function program()\
\
--api loading\
if not surface then\
	if fs.exists(surfacepath) then\
		os.loadAPI(surfacepath)\
	else\
		print(\"installing missing component: \" .. surfacepath)\
		pastebinGet(\"J2Y288mW\", surfacepath)\
		os.loadAPI(surfacepath)\
	end\
end\
--term args\
local home --the directory Lattix is opened in\
local root --the root directory that you're not allowed to go above\
\
if #tArgs > 0 then\
	home = tArgs[1]\
else\
	home = \"\"\
end\
if #tArgs > 1 then\
	root = tArgs[2]\
else\
	root = \"\"\
end\
\
root = fs.combine(\"\", root)\
home = fs.combine(\"\", home)\
\
--variables\
local clipboard --a file path/table of files\
local clip_cut = false -- original file(s) will be deleted if this is true\
local history = {}\
local w,h = term.getSize()\
\
\
\
--setting up path\
if not term.isColor() then\
	lat_theme = lat_basic_theme\
	dirprefix = basic_dirprefix\
	selectprefix = basic_selectprefix\
end\
local path = root\
\
if fs.isDir(fs.combine(root,home)) then\
	path = fs.combine(root,home)\
elseif fs.isDir(root) then\
	path = root\
else\
	error(\"Not valid root folder\",0)\
end\
local scroll = 0\
local selected = 0\
local endprogram = false\
local isCtrlDown = false\
local isShiftDown = false\
local selection = {}\
local isMultiSelect = false\
\
local index = 0\
local empty = function() end\
local shell_input = \"\"\
\
local itemNames = {} --displayed texts\
local itemPaths = {} --paths to items\
local customTitle --if not nil then the title of the program is replaced with this\
\
local prewrite = {} --for fancy command stuff\
\
--setting up the second session\
local alt_histories = {\
{path}, {path}, {path}, {path}\
}\
local alt_paths = {\
	[1] = path,\
	[2] = path,\
	[3] = path,\
	[4] = path\
}\
local alt_scrolls = {\
	0,0,0,0\
}\
local alt_selected = {\
	0,0,0,0\
}\
local cSession = 1\
\
local surf = surface.create(w,h,\" \",lat_theme.blank_back, lat_theme.blank_text) \
\
local pathValid = true\
\
--functions yet undefined:\
local redraw --so that any gui drawing can call a redraw\
local remap --so that redraw and remap can be overwritten if neccessary\
local restore --so that special popups that use the main loop can restore the file browser functionality\
--helpers\
local function mathdown(num)\
	if num % 1 ~= 0 then\
		return math.floor(num)\
	end\
	return num - 1\
end\
local function sort(path) --returns a sorted table of folder names and file names at path with folders being first\
	local tbl = {}\
	items = fs.list(path)\
	table.sort(items)\
	--insert dirs\
	for i=1,#items do\
		if fs.isDir(fs.combine(path,items[i])) then\
			tbl[#tbl+1] = fs.combine(path, items[i])\
		end\
	end\
	for i=1,#items do\
		if not fs.isDir(fs.combine(path,items[i])) then\
			tbl[#tbl+1] = fs.combine(path, items[i])\
		end\
	end\
	return tbl\
end\
local function formatNumber(num)\
	local extra = {\"B\",\"KB\",\"MB\"}\
	local eindex = 1\
	while num > 1024 do\
		num = num / 1024\
		num = math.floor(num)\
		eindex = eindex + 1\
	end\
	return tostring(num..extra[eindex])\
end\
local function posToIndex(maxn,x,y,scroll)\
	return y+scroll-2 < maxn and y+scroll-1 or 0\
end\
local function IndexToPos(index,scroll)\
	return 2,index-scroll\
end\
local function clear()\
	surf:clear()\
	surf:render()\
	term.setCursorPos(1,1)\
end\
\
local function readFolderRaw(folder)\
	customTitle = nil --to quit all special view modes\
	pathValid = true\
	path = folder\
	itemNames = {}\
	itemPaths = {}\
	\
	local t = sort(folder)\
	for i=1,#t do\
		itemNames[i] = fs.getName(t[i])\
		itemPaths[i] = t[i]\
	end\
	\
end\
\
local function switchFolderRaw(folder) --folder is in absolute path, does not add to history\
	readFolderRaw(folder)\
	selected = 0\
	scroll = 0\
	shell_input = \"\"\
end\
\
local function switchFolder(folder) --folder is in absolute path\
	history[#history + 1] = path\
	switchFolderRaw(folder)\
end\
\
local function waitForKeyOrClick()\
	while true do\
		local e = os.pullEvent()\
		if e == \"key\" or e == \"mouse_click\" then\
			break\
		end\
	end\
end\
local function split(inputstr, sep)\
        if sep == nil then\
                sep = \"%s\"\
        end\
        local t={} ; i=1\
        for str in string.gmatch(inputstr, \"([^\"..sep..\"]+)\") do\
                t[i] = str\
                i = i + 1\
        end\
        return t\
end\
local function switchSessions(newI)\
	--if newI == cSession then return end\
	alt_histories[cSession] = history\
	alt_paths[cSession] = path\
	alt_scrolls[cSession] = scroll\
	alt_selected[cSession] = selected\
	history = alt_histories[newI]\
	--after all we need to update the item list\
	switchFolderRaw(alt_paths[newI])\
	scroll = alt_scrolls[newI]\
	selected = alt_selected[newI]\
	cSession = newI\
end\
local function extensionRead(extension, width, bcolor, tcolor, dtext)\
	if #prewrite > 0 then\
		local tmp = prewrite[1]\
		table.remove(prewrite, 1)\
		return tmp\
	end\
	local x,y = term.getCursorPos()\
	term.setCursorBlink(true)\
	local t = dtext or \"\"\
	local i = #t\
	local scroll = 0\
	local tbasis\
	\
	while true do\
		surf:drawLine(x,y,x+width,y,\" \", bcolor,tcolor)\
		tbasis = t .. extension\
		if i < scroll then\
			scroll = i\
		end\
		if i > scroll + width - #extension then\
			scroll = i - width + #extension\
		end\
		if #tbasis > width then\
			if scroll + width > #tbasis then\
				scroll = #tbasis - width\
			end\
			tbasis = tbasis:sub(1+scroll, width+scroll)\
		else\
			scroll = 0\
		end\
		surf:drawText(x,y,tbasis,bcolor,tcolor)\
		surf:render()\
		term.setCursorPos(x+i-scroll, y)\
		local ev = {os.pullEvent()}\
		local e,k = ev[1], ev[2]\
		repeat\
			if e == \"paste\" then\
				e = \"char\"\
				table.remove(ev, 1)\
				k = table.concat(ev, \" \")\
			end\
			if e == \"char\" then\
				if i == #t then\
					t = t .. k\
					i = i + #k\
				elseif i == 0 then\
					t = k .. t\
					i = i + #k\
				else\
					t = t:sub(1,i) .. k .. t:sub(i+1, #t)\
					i = i + #k\
				end\
			end\
			\
			if e == \"key\" then\
				local mini = 0\
				local maxi = #t\
				if k == keys.left and i > mini then\
					i = i - 1\
					break\
				end\
				if k == keys.right and i < maxi then\
					i = i + 1\
					break\
				end\
				\
				if k == keys.up then\
					i = mini\
					break\
				end\
				if k == keys.down then\
					i = maxi\
					break\
				end\
				if k == keys.enter then\
					term.setCursorBlink(false)\
					return t .. extension\
				end\
				if k == keys.delete and i < #t then\
					t = t:sub(1,i) .. t:sub(i+2,#t)\
					break\
				end\
				if k == keys.backspace and i > 0 then\
					t = t:sub(1,i-1) .. t:sub(i+1, #t)\
					i = i - 1\
					break\
				end\
			end\
		until true\
	end\
end\
--custom dialoges (just the GUI, it also draws it)\
local function drawInfobox(txt) --just info text, no buttons\
	surf:fillRect(math.floor(w/2-(#txt+2)/2), math.floor(h/2)-2, math.floor(w/2+(#txt+2)/2),math.floor(h/2)+2, \" \", lat_theme.menu_back, lat_theme.menu_text)\
	surf:drawText(math.floor(w/2-(#txt+2)/2)+1,math.floor(h/2)-1, txt, lat_theme.menu_back, lat_theme.menu_text)\
	surf:render()\
end\
local function drawTextbox(txt) --text feedback\
	surf:fillRect(math.floor(w/2-(#txt+2)/2),math.floor(h/2)-2,math.floor(w/2+(#txt+2)/2),math.floor(h/2)+2, \" \", lat_theme.menu_back, lat_theme.menu_text)\
	surf:drawText(math.floor(w/2-(#txt+2)/2)+1,math.floor(h/2)-1, txt, lat_theme.menu_back, lat_theme.menu_text)\
	surf:render()\
	term.setCursorPos(math.floor(w/2-(#txt+2)/2)+1,math.floor(h/2)+1)\
end\
local function drawButtonBox(txt,buttons) --multiple buttons, configurable\
	if type(buttons) ~= \"table\" then\
		buttons = {{\" Yes \",colors.red,colors.white},{\" No \",colors.gray,colors.white}}\
	end\
	if txt == \"\" or txt == nil then\
		txt = \" Are you sure? \"\
	end\
	\
	drawTextbox(txt) --reuse the rectangle\
	local x,y = term.getCursorPos()\
	\
	for i=1,#buttons do\
		x = math.floor((w/2-(#txt+2)/2)+((#txt+2)/i)*(i-1)) + 1\
		if term.isColor() then\
			surf:drawText(x,y, buttons[i][1], buttons[i][2], buttons[i][3])\
		else\
			surf:drawText(x,y,buttons[i][1], lat_theme.main_back, lat_theme.main_text)\
		end\
	end\
	surf:render()\
	return y\
end\
local function drawPopupBox(x,y,buttons) --x and y are the corners\
	local ydir = y < h/2 and 1 or -1\
	surf:fillRect(x,y,x+15,y+(#buttons+1)*ydir, \" \", lat_theme.menu_back, lat_theme.menu_text)\
	for k,v in pairs(buttons) do\
		surf:drawText(x+1,y+k*ydir, v, lat_theme.menu_back, lat_theme.menu_text)\
	end\
	surf:render()\
end\
--custom dialogue functionality (difference from popups is that they stop the main program flow, program cannot close, etc. they are allowed to handle events)\
local function infoBox(txt, noredraw)\
	drawInfobox(txt)\
	waitForKeyOrClick()\
	if not noredraw then\
		redraw()\
	end\
end\
local function textBox(txt, dtext)\
	drawTextbox(txt)\
	local resp = extensionRead(\"\", #txt, lat_theme.menu_back, lat_theme.menu_text, dtext)\
	redraw()\
	return resp\
end\
local function xtensionTextBox(txt, xts)\
	drawTextbox(txt)\
	local resp = extensionRead(xts, #txt, lat_theme.menu_back, lat_theme.menu_text)\
	redraw()\
	return resp\
end\
local function fileChooseBox(txt)\
	return textBox(txt)\
end\
local function dirChooseBox(txt)\
	return textBox(txt)\
end\
local function buttonBox(txt, buttons)\
	local y = drawButtonBox(txt, buttons)\
	while true do\
		local _,b,x2,y2 = os.pullEvent(\"mouse_click\")\
		if b == 1 and y == y2 then\
			for i=1,#buttons do\
				local x = math.floor((w/2-(#txt+2)/2)+((#txt+2)/i)*(i-1)) + 1\
				if x2 > x - 1 and x2 < x + #buttons[i][1] then\
					redraw()\
					return i\
				end\
			end\
		end\
	end\
end\
--these were moved above popupbox:\
local function safeRun(func, ...)\
	local succ, msg = pcall(func, ...)\
	if not succ then\
		infoBox(msg)\
	end\
end\
local function refresh()\
	if pathValid then\
		readFolderRaw(path)\
	else\
		local t = {}\
		for k,v in pairs(itemPaths) do\
			if fs.exists(v) then\
				t[#t+1] = v\
			end\
		end\
		itemPaths = t\
	end\
end\
local function popupBox(x,y,buttons,functions) --popups defined to have width 15\
	drawPopupBox(x,y,buttons)\
	local ydir = y < h/2 and 1 or -1\
	while true do\
		local _,b,cx,cy = os.pullEvent(\"mouse_click\")\
		if b == 1 then\
			if cx < x or cx > x + 15 then\
				os.queueEvent(\"mouse_click\", b, cx, cy)\
				break\
			end\
			if not (cy*ydir > y*ydir and cy*ydir - y*ydir < #buttons+1) then\
				os.queueEvent(\"mouse_click\", b, cx, cy)\
				break\
			end\
			--for menus inside popup boxes\
			redraw()\
			safeRun(functions[ydir*cy-ydir*y],x,y)\
			refresh()\
			break\
		else\
			os.queueEvent(\"mouse_click\", b, cx, cy)\
			break\
		end\
	end\
	\
end\
\
local findFileBox --for later\
local findDirBox\
\
--file editing functionality\
local function run(path, ...)\
	local tArgs = {...}\
	local function box()\
		clear()\
		\
		shell.run(fs.combine(\"/\", path), unpack(tArgs)) --better alternative to shell.run?\
		print(\"Press any key or click to return to Lattix\")\
		waitForKeyOrClick()\
	end\
	local cor = coroutine.create(box)\
	coroutine.resume(cor)\
	--later better sandboxing required that doesn't allow modification of _G or some file defense\
	while (coroutine.status(cor) ~= \"dead\") do\
		local event = {os.pullEventRaw()} --terminate works only on the sub-program\
		coroutine.resume(cor, unpack(event))\
	end\
end\
local function mkdir(path, name)\
	fs.makeDir(fs.combine(path, name))\
end\
local function paste(path, clipboard, cutEnabled) --i wonder what happens if you try to move something inside of itself\
	if type(clipboard) == \"table\" then\
		for i=1,#clipboard do\
			paste(path, clipboard[i], cutEnabled)\
		end\
		return\
	end\
	if not clipboard then error(\"Clipboard is empty\",0) end\
	if not fs.exists(clipboard) then error(\"File copied doesn't exist\",0) end\
	local func = cutEnabled and fs.move or fs.copy\
	local goal = fs.combine(path, fs.getName(clipboard))\
	local i = 1\
	while fs.exists(goal) do\
		goal = fs.combine(path, \"Copy\" .. (i>1 and \" \" .. tostring(i) or \"\") .. \" of \" .. fs.getName(clipboard))\
		i = i + 1\
	end\
	func(clipboard, goal)\
end\
local function advFind(path, wildcard, results)\
	if not results then results = {} end\
	local t = fs.find(fs.combine(path, wildcard))\
	for i=1,#t do\
		results[#results+1] = t[i]\
	end\
	local dirs = fs.list(path)\
	for i=1,#dirs do\
		if fs.isDir(fs.combine(path, dirs[i])) then\
			results = advFind(fs.combine(path, dirs[i]), wildcard, results)\
		end\
	end\
	\
	return results\
end\
--GUI core functionality\
\
local function doubleClick(path) --contains a reference to refresh\
	selected = 0\
	if fs.isDir(path) then\
		switchFolder(path)\
	else\
		local elements = split(fs.getName(path), \".\")\
		if #elements == 1 then\
			elements[2] = \"\" --no extension\
		end\
		if not defaultPrograms[elements[#elements]] then\
			elements[#elements] = \"def\" --unknown extension\
		end\
		if (defaultPrograms[elements[#elements]]) == \"api\" then\
			os.loadAPI(path)\
			refresh()\
		elseif defaultPrograms[elements[#elements]] == \"run\" then\
			run(path)\
			refresh()\
		else\
			shell.run(defaultPrograms[elements[#elements]], path)\
			refresh()\
		end\
	end\
end\
local function gotoFolder()\
	local target\
		target = textBox(\"Please specify target folder\")\
		if target == \"\" then return end --cancel if empty\
		if not target or not fs.exists(target) or not fs.isDir(target) then\
			infoBox(\"    Not a valid directory   \")\
			return\
		end\
		switchFolder(fs.combine(\"\", target))\
end\
local function makeDirPrompt()\
	local name = textBox(\"Enter the name of the new directory\")\
	if name == \"\" then return end\
	if fs.exists(fs.combine(path, name)) then\
		infoBox(\"Failure - File name already used\")\
	end\
	mkdir(path, name)\
end\
local function pastebin()\
	local link = textBox(\"Enter the pastebin link\")\
	if link == \"\" then return end\
	local name = textBox(\"Enter the name of the file\")\
	if name == \"\" then return end\
	if fs.exists(fs.combine(path,name)) then\
		infoBox(\"Failure - File name already used\")\
		return\
	end\
	local succ, err = pcall(pastebinGet,link, fs.combine(path, name))\
	if not succ then\
		infoBox(err)\
	end\
end\
local function wgetPrompt()\
	local link = textBox(\"Enter the url\")\
	if link == \"\" then return end\
	local name = textBox(\"Enter the name of the file\")\
	if name == \"\" then return end\
	if fs.exists(fs.combine(path,name)) then\
		infoBox(\"Failure - File name already used\")\
		return\
	end\
	local succ, err = pcall(wGet,link, fs.combine(path, name))\
	if not succ then\
		infoBox(err)\
	end\
end\
local function runPrompt(appath)\
	if not appath then\
		appath = fs.combine(path, textBox(\"Enter the name of the script\"))\
	end\
	if not fs.exists(appath) then\
		infoBox(\"Script doesn't exist: \" .. appath)\
		return\
	end\
	if fs.isDir(appath) then\
		infoBox(\"Cannot run a directory: \" .. appath)\
		return\
	end\
	args = textBox(\"Please enter the arguments\")\
	run(appath, split(args, \" \"))\
end\
local function copy(name)--name actually means full path\
	clip_cut = false\
	clipboard = name\
end\
local function cut(name) --name actually means full path here\
	copy(name)\
	clip_cut = true\
end\
local function renamePrompt(path)\
	if not fs.exists(path) then infoBox(\"Nothing to rename\") return end\
	local name = textBox(\"Enter the new name\", fs.getName(path))\
	if name == \"\" then return end\
	if fs.exists(fs.combine(fs.getDir(path), name)) then\
		infoBox(\"Failure - File already exists\")\
		return\
	end\
	fs.move(path, fs.combine(fs.getDir(path), name))\
	selected = 0\
end\
local function deletePrompt(path)\
	if not fs.exists(path) then infoBox(\"Nothing to delete\") return end\
	local response = buttonBox(\"Do you really want to delete \" .. fs.getName(path) .. \"?\", {{\" Delete \", colors.white, colors.red}, {\" Cancel \", colors.yellow, colors.black }})\
	if response == 1 then\
		fs.delete(path)\
	end\
	selected = 0\
end\
local function findFilesPrompt()\
	local wildCard = textBox(\"Enter filename or part of it\")\
	if wildCard == \"\" then return end --cancel option\
	local finds = advFind(path, \"*\" .. wildCard .. \"*\")\
	if #finds == 0 then\
		infoBox(\"No files found\")\
		return\
	end\
	itemNames = {}\
	itemPaths = {}\
	selected = 0\
	scroll = 0\
	for i=1,#finds do\
		itemNames[i] = finds[i]\
		itemPaths[i] = finds[i]\
		customTitle = \"Search results\"\
		pathValid = false\
	end\
	\
end\
--GUI functionality - event mapping\
local buttons = {}\
local keymap = {}\
local eventmap = {}\
\
for i=1,w do\
	buttons[i] = {}\
	for j=1,h do\
	\
		buttons[i][j] = {function() end, function() end}\
	end\
end\
local function newButton(x, y, w, h, func_left, func_right)\
	for i=x, x+w-1 do\
		for j=y, y+h-1 do\
			buttons[i][j] = {func_left, func_right}\
		end\
	end\
end\
local function clearButtons(x, y, w, h)\
	newButton(x,y,w,h, empty, empty)\
end\
\
local function clearAllEvents()\
	keymap = {}\
	eventmap = {}\
	clearButtons(1,1,w,h)\
end\
--mappings:\
local popup_newmenu_names = {\
	\"New ...\",\
	\"New dir\",\
	\"Paste\",\
	\"Pastebin\",\
	\"wget\"\
}\
local popup_newmenu_functions = {\
	function(x,y) \
		local options = {}\
		local functions = {}\
		for k,v in pairs(editors) do\
			local i = #options+1 \
			options[i] = k\
			functions[i] = function()\
				local ext = \"\"\
				if editors_extensions[k] then\
					ext = editors_extensions[k]\
				end\
				local app\
				if v == \"choose\" then\
					\
				else\
					app = v\
				end\
				local item = xtensionTextBox(\"What should the new file be called?\", \".\" .. ext)\
				local target = fs.combine(path, item)\
				if not fs.exists(target) then\
					shell.run(app, target)\
				else\
					infoBox(\"Failure - file already exists\")\
				end\
			end\
		end\
		popupBox(x,y,options,functions)\
	end,\
	function() makeDirPrompt() end,\
	function() paste(path, clipboard, clip_cut) end,\
	function() pastebin() end,\
	function() wgetPrompt() end,\
	\
}\
\
\
\
\
\
local popup_lockednewmenu_names = {\
	\"Refresh\"\
}\
local popup_lockednewmenu_functions = {\
	function() refresh() end\
}\
\
local popup_menu_names = {\
	\"Go to dir\",\
	\"Find file\",\
	\"Version: \"..version\
}\
local popup_menu_functions = {\
	function() gotoFolder() end,\
	function() findFilesPrompt() end,\
	function() infoBox(\"Lattix version \" .. version) end,\
}\
local menu_functions = {\
	back = function() \
		if not pathValid then\
			pathValid = true\
			refresh()\
			\
			return\
		end\
		if #history > 1 then\
			switchFolderRaw(history[#history])\
			table.remove(history, #history)\
		end\
	end,\
	up = function()\
		if not pathValid then\
			pathValid = true\
			refresh()\
			return\
		end\
		if path == \"\" or path == \"/\" then return end\
		switchFolder(fs.combine(path, \"..\"))\
	end,\
	menu = function()\
		--open advanced menu\
		popupBox(9,2,popup_menu_names, popup_menu_functions)\
	end,\
	root = function()\
		if not pathValid then\
			pathValid = true\
		end\
		switchFolder(root)\
	end,\
	plus = function()\
		--open new menu\
		if pathValid then\
			popupBox(5,2,popup_newmenu_names, popup_newmenu_functions)\
		else\
			popupBox(5,2,popup_lockednewmenu_names, popup_lockednewmenu_functions)\
		end\
	end,\
	quit = function()\
		clear()\
		endprogram = true\
	end\
}\
local filePopupNames = {\
--	\"Edit\", --opens default editor, as double click would, expect that for .lua it opens edit too\
	\"Run\", --runs\
	\"Run w/ args\", --runs with args\
--	\"Open With\", --select a program from a list and use it to open this, config file will be huge i see\
	\"Rename\",\
	\"Copy\",\
	\"Cut\",\
	\"Delete\"\
}\
local function getSelectedPath()\
	return itemPaths[selected]\
end\
local filePopupFunctions = {\
	function(x,y) run(getSelectedPath()) end,--run\
	function(x,y) runPrompt(getSelectedPath()) end,--run w args\
	function(x,y) renamePrompt(getSelectedPath()) end, --rename,\
	function(x,y) copy(getSelectedPath()) end, --copy\
	function(x,y) cut (getSelectedPath()) end, --cut\
	function(x,y) deletePrompt(getSelectedPath()) end --delete\
}\
local folderPopupNames = {\
	\"Open\",\
--	\"Open in ...\", --1,2,3,4 and program, TODO later bc open in and open with need some design decisions\
--	\"Unpack\",\
	\"Rename\",\
	\"Copy\",\
	\"Cut\",\
	\"Delete\"\
}\
local folderPopupFunctions = {\
	function(x,y) switchFolder(getSelectedPath()) end, --open\
	function(x,y) renamePrompt(getSelectedPath()) end, --rename\
	function(x,y) copy(getSelectedPath()) end, --copy\
	function(x,y) cut(getSelectedPath()) end, --cut\
	function(x,y) deletePrompt(getSelectedPath()) end --delete\
}\
local multiPopupNames = {}\
local multiPopupFunctions = {}--for multiselect, copy, cut, pack into folder, delete\
\
local commands = { --table of functions, arg: list of words typed, including the command itself\
	[\"run\"] = function(words)\
		if #words == 1 then\
			runPrompt()\
			return\
		end\
		\
		local torun\
		for i=1,#itemNames do\
			if words[2] == itemNames[i] then\
				torun = i\
				break\
			end\
		end\
		if not torun then return end\
		local args = {}\
		if #words > 2 then\
			for i=3, #words do\
				args[i-2] = words[i]\
			end\
		end\
		if fs.exists(itemPaths[torun]) and not fs.isDir(itemPaths[torun]) then\
			run(itemPaths[torun], unpack(args))\
		end\
	end,\
	[\"goto\"] = function(words)\
		local target\
		if #words < 2 then\
			gotoFolder()\
			return\
		else\
			target = words[2]\
		end\
		--from local path\
		if target:sub(1,1) ~= \"/\" and fs.exists(fs.combine(path, target)) and fs.isDir(fs.combine(path, target)) then\
			switchFolder(fs.combine(path, target))\
			return\
		end\
		--from absolute path\
		if not target or not fs.exists(target) or not fs.isDir(target) then\
			infoBox(\"Not a valid directory\")\
			return\
		end\
		switchFolder(fs.combine(\"\", target))\
	end,\
	[\"deselect\"] = function(words)\
		selected = 0\
	end,\
	[\"select\"] = function(words)\
		--deselect cuz no arg\
		if #words < 2 then\
			selected = 0\
			return\
		end\
		--select by name\
		for i=1, #itemNames do\
			if itemNames[i] == words[2] then\
				selected = i\
				return\
			end\
		end\
		\
		--select by index\
		local index = tonumber(words[2])\
		if index and index == math.floor(index) and index <= #itemPaths and index >= 0 then\
			selected = index\
			return\
		end\
		\
	end,\
	[\"count\"] = function(words)\
		infoBox(\"Number of items: \" .. #itemPaths)\
	end,\
	[\"up\"] = function(words)\
		menu_functions.up()\
	end,\
	[\"root\"] = function(words)\
		menu_functions.root()\
	end,\
	[\"quit\"] = function(words)\
		menu_functions.quit()\
	end,\
	[\"back\"] = function(words)\
		menu_functions.back()\
	end,\
	[\"switch\"] = function(words)\
		if #words < 2 then\
			local nses = cSession + 1\
			switchSessions(nses < 5 and nses or 1)\
			return\
		end\
		local index = tonumber(words[2])\
		if index and index == math.floor(index) and index <= 4 and index >= 1 then\
			switchSessions(index)\
		end\
	end,\
	[\"help\"] = function(words)\
		infoBox(\" Read the Lattix CC forum post, commands section \")\
	end,\
}\
local function raw(str)\
	str = str:lower()\
	str = str:gsub(' ','')\
	str = str:gsub('_', '')\
	return str\
end\
local function evaulate(nametbl, functbl, name)\
	for i=1, #nametbl do\
		if raw(nametbl[i]) == raw(name) then\
			return functbl[i]\
		end\
	end\
end\
local alias = {\
	[\"cd\"] = \"goto\",\
	[\"mkdir\"] = \"newdir\",\
	[\"find\"] = \"findfile\",\
	[\"search\"] = \"find\",\
	[\"about\"] = \"version:\" .. version,\
	[\"version\"] = \"version:\"..version,\
	[\"exit\"] = \"quit\",\
	[\"..\"] = \"back\",\
	[\"/\"] = \"root\",\
	[\"x\"] = \"quit\",\
	[\"#\"] = \"count\"\
}\
\
local mt = {\
	__index = function(tbl, i)\
		local function fullEval()\
			if raw(i) == raw(\"new...\") then\
				return nil\
			end\
			local func\
			if pathValid then\
				func = evaulate(popup_newmenu_names, popup_newmenu_functions, i)\
				if func then return func end\
			else\
				func = evaulate(popup_lockednewmenu_names, popup_lockednewmenu_functions, i)\
				if func then return func end\
			end\
			func = evaulate(popup_menu_names, popup_menu_functions, i)\
			if func then return func end\
			--if multiselection...\
			if selected ~= 0 and itemPaths[selected] and fs.exists(itemPaths[selected]) then\
				if fs.isDir(itemPaths[selected]) then\
					func = evaulate(folderPopupNames, folderPopupFunctions, i)\
					if func then return func end\
				else\
					func = evaulate(filePopupNames, filePopupFunctions, i)\
					if func then return func end\
				end\
			end\
		end\
		local final\
		while true do\
			final = fullEval()\
			if final then break end\
			if not alias[raw(i)] then\
				break\
			end\
			i = alias[raw(i)]\
			if commands[i] then final = commands[i] break end\
		end\
		return final\
	end\
}\
setmetatable(commands, mt)\
\
\
\
local function mapMenu()\
	\
	local switch = function(e)\
		switchSessions(e[3]-w+6)\
	end\
	newButton(1,1,1,1, menu_functions.back, empty)\
	newButton(3,1,1,1, menu_functions.up, empty)\
	newButton(7,1,1,1, menu_functions.root, empty)\
	newButton(5,1,1,1, menu_functions.plus, empty)\
	newButton(9,1,1,1, menu_functions.menu, empty)\
	newButton(w,1,1,1, menu_functions.quit, empty)\
	newButton(w-5,1,4,1, switch, empty) \
	keymap[keys.left] = up\
end\
local drawFiles\
\
local function enterPress()\
	words = split(shell_input, \" \")\
	if words and #words > 0 then\
		if commands[words[1]:lower()] then\
			prewrite = {}\
			if #words > 1 then\
				for i=2, #words do\
					prewrite[i-1] = words[i]\
				end\
			end\
			commands[words[1]:lower()](words)\
			refresh()\
			prewrite = {}\
		else\
			infoBox(\"Unknown command: \" .. words[1]:lower())\
		end\
	elseif selected > 0 and selected <= #itemPaths then\
		doubleClick(itemPaths[selected])\
	end\
	shell_input = \"\"\
end\
local function filePopup(x,y,path)\
	if fs.isDir(path) then\
		--directory\
		popupBox(x,y,folderPopupNames, folderPopupFunctions)\
	else\
		--file\
		popupBox(x,y,filePopupNames, filePopupFunctions)\
	end\
end\
local function mapFiles()\
	--popup menu implementation (right click)\
	local file_rightclick = function(e)\
		local i = posToIndex(#itemNames,e[3],e[4],scroll) --get index\
		if itemPaths[i] then\
			if selected ~= i then --select if not selected\
				selected = i --just for aesthetics\
				redraw()\
			end\
			--show file/folder/multiselect relevant popup\
			if selection and #selection > 0 then\
				--multiselect\
			else\
				filePopup(e[3],e[4],getSelectedPath())\
			end\
		else\
			selected = 0\
			--show the same popup as the + button in the menu\
			if pathValid then\
				popupBox(e[3],e[4],popup_newmenu_names, popup_newmenu_functions)\
			else\
				popupBox(e[3], e[4], popup_lockednewmenu_names, popup_lockednewmenu_functions)\
			end\
		end\
	end\
	--select implementation (left click)\
	local file_leftclick = function(e)\
		local i = posToIndex(#itemNames,e[3],e[4],scroll)\
		if itemPaths[i] then\
			if selected == i then\
				doubleClick(itemPaths[i])\
			else\
				selected = i\
			end\
		else\
			selected = 0\
		end\
	end\
	\
	newButton(1,2,w,h-2,file_leftclick, file_rightclick)\
	--multiselect stuff\
	\
	--scrolling\
	eventmap[\"mouse_scroll\"] = function(e)\
		local b = e[2]\
		if b == 1 and #itemPaths - scroll > h-2 then\
			scroll = scroll + 1\
		end\
		if b == -1 and scroll > 0 then\
			scroll = scroll - 1\
		end\
	end\
	\
	keymap[keys.enter] = enterPress\
	keymap[keys.up] = function()\
		if selected > 1 then\
			selected = selected - 1\
			if scroll >= selected then\
				scroll = selected - 1\
			end\
		end\
		if selected == 0 then\
			selected = #itemPaths\
			if scroll + h - 2 < selected then\
				scroll = selected - h + 2\
			end\
		end\
	end\
	keymap[keys.down] = function()\
		if selected < #itemPaths then\
			selected = selected + 1\
			if scroll + h - 2 < selected then\
				scroll = selected - h + 2\
			end\
		end\
	end\
	keymap[keys.right] = function()\
		if selected > 0 and selected <= #itemPaths then\
			local x,y = IndexToPos(selected, scroll)\
			if x < 2 then\
				x = 2\
			end\
			if x > h-1 then\
				x = h-1\
			end\
			filePopup(x,y, getSelectedPath()) \
		end\
	end\
end\
\
local function mapBar()\
	eventmap.char = function(e) \
		shell_input = shell_input .. e[2]\
	end\
	keymap[keys.backspace] = function()\
		shell_input = shell_input:sub(1, #shell_input-1)\
	end\
	--enter is mapped in mapFiles for the bar too\
end\
--draw components\
local function drawMenu()\
	surf:drawLine(1,1,w,1,\" \", lat_theme.menu_back, lat_theme.menu_text)\
	if term.isColor() then\
		surf:drawText(1,1,\"< ^ + / m\", lat_theme.menu_back, lat_theme.menu_text)\
	end\
	local str\
	if customTitle then\
		str = customTitle\
	else\
		if path ~= \"\" then\
			str = cSession .. \" - \" .. path\
		else\
			str = tostring(cSession)\
		end\
	end\
	str = #str < w/2 and str or str:sub(1,math.floor(w/2)) .. \"...\"\
	surf:drawText(8+math.floor((w-12)/2-#str/2),1,str, lat_theme.menu_back, lat_theme.menu_text)\
	\
	if term.isColor() then\
		surf:drawText(w-5,1,\"1234\", lat_theme.menu_back, lat_theme.menu_text)\
		surf:drawPixel(w,1,\"x\", colors.red, colors.white)\
	end\
	\
end\
\
drawFiles = function()\
	if selection == nil then selection = {} end --just in case selection was nilled\
	local cy = 2 --current y pos of drawing\
	local i = scroll + 1 --index in \"items\"\
	local tcol\
	local bcol\
	while IndexToPos(i,scroll) < h do\
		if not itemNames[i] then break end --because the while condition checks for screen size, this checks for file count\
		local twrite = \"\"\
		bcol = (lat_theme.main_back)\
		if selection[i] then\
			bcol = (lat_theme.multiselect_back)\
			twrite = twrite .. selectprefix\
		end\
		if i ~= selected then\
			if not fs.isDir(itemPaths[i]) then\
				tcol = (lat_theme.main_text)\
			else\
				tcol = (lat_theme.dir_text)\
				\
			end\
		else\
			tcol = (lat_theme.selected_text)\
		end\
		if fs.isDir(itemPaths[i]) then\
			twrite = twrite .. dirprefix\
		end\
		twrite = twrite .. itemNames[i]\
		surf:drawLine(1, cy, w, cy, \" \", bcol, tcol)\
		surf:drawText(2, cy, twrite, bcol, tcol)\
		local mwrite = \"-\"\
		if not fs.isDir(itemPaths[i]) then\
			mwrite = formatNumber(fs.getSize(itemPaths[i]))\
		end\
		local startX = w-6\
		surf:drawLine(startX-1, cy, w, cy, \" \", bcol, tcol)\
		surf:drawText(startX,cy, mwrite, bcol, tcol)\
		i = i + 1\
		cy = cy + 1 --up both indexes\
	end\
	return itemNames\
end\
\
local function drawBar()\
	surf:drawLine(1,h,w,h, \" \", lat_theme.menu_back, lat_theme.menu_text)\
	surf:drawText(1,h, path .. \"> \" .. shell_input, lat_theme.menu_back, lat_theme.menu_text)\
end\
\
\
--GUI drawing functions\
redraw = function()\
	if not fs.exists(path) or not fs.isDir(path) then\
		infoBox(\"Error: \" .. path .. \" is not a valid directory\", true)\
		path = root\
	end\
	\
	surf:clear(\" \", lat_theme.blank_back, lat_theme.blank_text)\
	drawMenu()\
	\
	drawFiles()\
	\
	drawBar()\
	\
	surf:render()\
end\
\
remap = function()\
	clearAllEvents()\
	mapMenu()\
	mapFiles()\
	mapBar()\
end\
local oRedraw = redraw --orginal backup\
local oRemap = remap\
restore = function()\
	redraw = oRedraw\
	remap = oRemap\
end\
\
do --choose file/folder dialog\
\
end\
\
switchFolder(path)\
\
--main loop\
while not endprogram do\
	redraw()\
	remap()\
	local e = { os.pullEvent() }\
	if e[1] == \"mouse_click\" then\
		buttons[e[3]][e[4]][e[2]](e)\
	elseif e[1] == \"key\" then\
		if keymap[e[2]] then\
			keymap[e[2]](e)\
		end\
	elseif eventmap[e[1]] then\
		eventmap[e[1]](e)\
	end	\
end\
\
end\
\
local succ, msg = pcall(program)\
\
term.setBackgroundColor(colors.black)\
term.setTextColor(colors.white)\
term.clear()\
term.setCursorPos(1,1)\
	\
if not succ and msg ~= \"Terminated\" then\
	print(\"Congratulations, Lattix has crashed\")\
	print()\
	print(\"Please report with steps to reproduce to the forum post to get your name added to the credits\")\
	print()\
	print(msg)\
end\
if succ or msg == \"Terminated\" then\
	print(\"[Lattix]: bye\")\
	print()\
	print(msg or \"version \" .. version)\
end",
    [ "sys/apps/luaide" ] = "\
--  \
--  Lua IDE\
--  Made by GravityScore\
--  \
\
\
--  -------- Variables\
\
-- Version\
local version = \"1.0\"\
local args = {...}\
\
-- Editing\
local w, h = term.getSize()\
local tabWidth = 2\
\
local autosaveInterval = 20\
local allowEditorEvent = true\
local keyboardShortcutTimeout = 0.4\
\
-- Clipboard\
local clipboard = nil\
\
-- Theme\
local theme = {}\
\
-- Language\
local languages = {}\
local curLanguage = {}\
\
-- Events\
local event_distract = \"luaide_distractionEvent\"\
\
-- Locations\
local updateURL = \"https://raw.github.com/GravityScore/LuaIDE/master/luaide.lua\"\
local ideLocation = \"/\" .. shell.getRunningProgram()\
local themeLocation = \"/.LuaIDE-Theme\"\
\
local function isAdvanced() return term.isColor and term.isColor() end\
\
\
--  -------- Utilities\
\
local function modRead(properties)\
	local w, h = term.getSize()\
	local defaults = {replaceChar = nil, history = nil, visibleLength = nil, textLength = nil, \
		liveUpdates = nil, exitOnKey = nil}\
	if not properties then properties = {} end\
	for k, v in pairs(defaults) do if not properties[k] then properties[k] = v end end\
	if properties.replaceChar then properties.replaceChar = properties.replaceChar:sub(1, 1) end\
	if not properties.visibleLength then properties.visibleLength = w end\
\
	local sx, sy = term.getCursorPos()\
	local line = \"\"\
	local pos = 0\
	local historyPos = nil\
\
	local function redraw(repl)\
		local scroll = 0\
		if properties.visibleLength and sx + pos > properties.visibleLength + 1 then \
			scroll = (sx + pos) - (properties.visibleLength + 1)\
		end\
\
		term.setCursorPos(sx, sy)\
		local a = repl or properties.replaceChar\
		if a then term.write(string.rep(a, line:len() - scroll))\
		else term.write(line:sub(scroll + 1, -1)) end\
		term.setCursorPos(sx + pos - scroll, sy)\
	end\
\
	local function sendLiveUpdates(event, ...)\
		if type(properties.liveUpdates) == \"function\" then\
			local ox, oy = term.getCursorPos()\
			local a, data = properties.liveUpdates(line, event, ...)\
			if a == true and data == nil then\
				term.setCursorBlink(false)\
				return line\
			elseif a == true and data ~= nil then\
				term.setCursorBlink(false)\
				return data\
			end\
			term.setCursorPos(ox, oy)\
		end\
	end\
\
	term.setCursorBlink(true)\
	while true do\
		local e, but, x, y, p4, p5 = os.pullEvent()\
\
		if e == \"char\" then\
			local s = false\
			if properties.textLength and line:len() < properties.textLength then s = true\
			elseif not properties.textLength then s = true end\
\
			local canType = true\
			if not properties.grantPrint and properties.refusePrint then\
				local canTypeKeys = {}\
				if type(properties.refusePrint) == \"table\" then\
					for _, v in pairs(properties.refusePrint) do\
						table.insert(canTypeKeys, tostring(v):sub(1, 1))\
					end\
				elseif type(properties.refusePrint) == \"string\" then\
					for char in properties.refusePrint:gmatch(\".\") do\
						table.insert(canTypeKeys, char)\
					end\
				end\
				for _, v in pairs(canTypeKeys) do if but == v then canType = false end end\
			elseif properties.grantPrint then\
				canType = false\
				local canTypeKeys = {}\
				if type(properties.grantPrint) == \"table\" then\
					for _, v in pairs(properties.grantPrint) do\
						table.insert(canTypeKeys, tostring(v):sub(1, 1))\
					end\
				elseif type(properties.grantPrint) == \"string\" then\
					for char in properties.grantPrint:gmatch(\".\") do\
						table.insert(canTypeKeys, char)\
					end\
				end\
				for _, v in pairs(canTypeKeys) do if but == v then canType = true end end\
			end\
\
			if s and canType then\
				line = line:sub(1, pos) .. but .. line:sub(pos + 1, -1)\
				pos = pos + 1\
				redraw()\
			end\
		elseif e == \"key\" then\
			if but == keys.enter then break\
			elseif but == keys.left then if pos > 0 then pos = pos - 1 redraw() end\
			elseif but == keys.right then if pos < line:len() then pos = pos + 1 redraw() end\
			elseif (but == keys.up or but == keys.down) and properties.history then\
				redraw(\" \")\
				if but == keys.up then\
					if historyPos == nil and #properties.history > 0 then \
						historyPos = #properties.history\
					elseif historyPos > 1 then \
						historyPos = historyPos - 1\
					end\
				elseif but == keys.down then\
					if historyPos == #properties.history then historyPos = nil\
					elseif historyPos ~= nil then historyPos = historyPos + 1 end\
				end\
\
				if properties.history and historyPos then\
					line = properties.history[historyPos]\
					pos = line:len()\
				else\
					line = \"\"\
					pos = 0\
				end\
\
				redraw()\
				local a = sendLiveUpdates(\"history\")\
				if a then return a end\
			elseif but == keys.backspace and pos > 0 then\
				redraw(\" \")\
				line = line:sub(1, pos - 1) .. line:sub(pos + 1, -1)\
				pos = pos - 1\
				redraw()\
				local a = sendLiveUpdates(\"delete\")\
				if a then return a end\
			elseif but == keys.home then\
				pos = 0\
				redraw()\
			elseif but == keys.delete and pos < line:len() then\
				redraw(\" \")\
				line = line:sub(1, pos) .. line:sub(pos + 2, -1)\
				redraw()\
				local a = sendLiveUpdates(\"delete\")\
				if a then return a end\
			elseif but == keys[\"end\"] then\
				pos = line:len()\
				redraw()\
			elseif properties.exitOnKey then \
				if but == properties.exitOnKey or (properties.exitOnKey == \"control\" and \
						(but == 29 or but == 157)) then \
					term.setCursorBlink(false)\
					return nil\
				end\
			end\
		end\
		local a = sendLiveUpdates(e, but, x, y, p4, p5)\
		if a then return a end\
	end\
\
	term.setCursorBlink(false)\
	if line ~= nil then line = line:gsub(\"^%s*(.-)%s*$\", \"%1\") end\
	return line\
end\
\
\
--  -------- Themes\
\
local defaultTheme = {\
	background = \"gray\",\
	backgroundHighlight = \"lightGray\",\
	prompt = \"cyan\",\
	promptHighlight = \"lightBlue\",\
	err = \"red\",\
	errHighlight = \"pink\",\
\
	editorBackground = \"gray\",\
	editorLineHightlight = \"lightBlue\",\
	editorLineNumbers = \"gray\",\
	editorLineNumbersHighlight = \"lightGray\",\
	editorError = \"pink\",\
	editorErrorHighlight = \"red\",\
\
	textColor = \"white\",\
	conditional = \"yellow\",\
	constant = \"orange\",\
	[\"function\"] = \"magenta\",\
	string = \"red\",\
	comment = \"lime\"\
}\
\
local normalTheme = {\
	background = \"black\",\
	backgroundHighlight = \"black\",\
	prompt = \"black\",\
	promptHighlight = \"black\",\
	err = \"black\",\
	errHighlight = \"black\",\
\
	editorBackground = \"black\",\
	editorLineHightlight = \"black\",\
	editorLineNumbers = \"black\",\
	editorLineNumbersHighlight = \"white\",\
	editorError = \"black\",\
	editorErrorHighlight = \"black\",\
\
	textColor = \"white\",\
	conditional = \"white\",\
	constant = \"white\",\
	[\"function\"] = \"white\",\
	string = \"white\",\
	comment = \"white\"\
}\
\
local availableThemes = {\
	{\"Water (Default)\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/default.txt\"},\
	{\"Fire\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/fire.txt\"},\
	{\"Sublime Text 2\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/st2.txt\"},\
	{\"Midnight\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/midnight.txt\"},\
	{\"TheOriginalBIT\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/bit.txt\"},\
	{\"Superaxander\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/superaxander.txt\"},\
	{\"Forest\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/forest.txt\"},\
	{\"Night\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/night.txt\"},\
	{\"Original\", \"https://raw.github.com/GravityScore/LuaIDE/master/themes/original.txt\"},\
}\
\
local function loadTheme(path)\
	local f = io.open(path)\
	local l = f:read(\"*l\")\
	local config = {}\
	while l ~= nil do\
		local k, v = string.match(l, \"^(%a+)=(%a+)\")\
		if k and v then config[k] = v end\
		l = f:read(\"*l\")\
	end\
	f:close()\
	return config\
end\
\
-- Load Theme\
if isAdvanced() then theme = defaultTheme\
else theme = normalTheme end\
\
\
--  -------- Drawing\
\
local function centerPrint(text, ny)\
	if type(text) == \"table\" then for _, v in pairs(text) do centerPrint(v) end\
	else\
		local x, y = term.getCursorPos()\
		local w, h = term.getSize()\
		term.setCursorPos(w/2 - text:len()/2 + (#text % 2 == 0 and 1 or 0), ny or y)\
		print(text)\
	end\
end\
\
local function title(t)\
	term.setTextColor(colors[theme.textColor])\
	term.setBackgroundColor(colors[theme.background])\
	term.clear()\
\
	term.setBackgroundColor(colors[theme.backgroundHighlight])\
	for i = 2, 4 do term.setCursorPos(1, i) term.clearLine() end\
	term.setCursorPos(3, 3)\
	term.write(t)\
end\
\
local function centerRead(wid, begt)\
	local function liveUpdate(line, e, but, x, y, p4, p5)\
		if isAdvanced() and e == \"mouse_click\" and x >= w/2 - wid/2 and x <= w/2 - wid/2 + 10 \
				and y >= 13 and y <= 15 then\
			return true, \"\"\
		end\
	end\
\
	if not begt then begt = \"\" end\
	term.setTextColor(colors[theme.textColor])\
	term.setBackgroundColor(colors[theme.promptHighlight])\
	for i = 8, 10 do\
		term.setCursorPos(w/2 - wid/2, i)\
		term.write(string.rep(\" \", wid))\
	end\
\
	if isAdvanced() then\
		term.setBackgroundColor(colors[theme.errHighlight])\
		for i = 13, 15 do\
			term.setCursorPos(w/2 - wid/2 + 1, i)\
			term.write(string.rep(\" \", 10))\
		end\
		term.setCursorPos(w/2 - wid/2 + 2, 14)\
		term.write(\"> Cancel\")\
	end\
\
	term.setBackgroundColor(colors[theme.promptHighlight])\
	term.setCursorPos(w/2 - wid/2 + 1, 9)\
	term.write(\"> \" .. begt)\
	return modRead({visibleLength = w/2 + wid/2, liveUpdates = liveUpdate})\
end\
\
\
--  -------- Prompt\
\
local function prompt(list, dir, isGrid)\
	local function draw(sel)\
		for i, v in ipairs(list) do\
			if i == sel then term.setBackgroundColor(v.highlight or colors[theme.promptHighlight])\
			else term.setBackgroundColor(v.bg or colors[theme.prompt]) end\
			term.setTextColor(v.tc or colors[theme.textColor])\
			for i = -1, 1 do\
				term.setCursorPos(v[2], v[3] + i)\
				term.write(string.rep(\" \", v[1]:len() + 4))\
			end\
\
			term.setCursorPos(v[2], v[3])\
			if i == sel then\
				term.setBackgroundColor(v.highlight or colors[theme.promptHighlight])\
				term.write(\" > \")\
			else term.write(\" - \") end\
			term.write(v[1] .. \" \")\
		end\
	end\
\
	local key1 = dir == \"horizontal\" and 203 or 200\
	local key2 = dir == \"horizontal\" and 205 or 208\
	local sel = 1\
	draw(sel)\
\
	while true do\
		local e, but, x, y = os.pullEvent()\
		if e == \"key\" and but == 28 then\
			return list[sel][1]\
		elseif e == \"key\" and but == key1 and sel > 1 then\
			sel = sel - 1\
			draw(sel)\
		elseif e == \"key\" and but == key2 and ((err == true and sel < #list - 1) or (sel < #list)) then\
			sel = sel + 1\
			draw(sel)\
		elseif isGrid and e == \"key\" and but == 203 and sel > 2 then\
			sel = sel - 2\
			draw(sel)\
		elseif isGrid and e == \"key\" and but == 205 and sel < 3 then\
			sel = sel + 2\
			draw(sel)\
		elseif e == \"mouse_click\" then\
			for i, v in ipairs(list) do\
				if x >= v[2] - 1 and x <= v[2] + v[1]:len() + 3 and y >= v[3] - 1 and y <= v[3] + 1 then\
					return list[i][1]\
				end\
			end\
		end\
	end\
end\
\
local function scrollingPrompt(list)\
	local function draw(items, sel, loc)\
		for i, v in ipairs(items) do\
			local bg = colors[theme.prompt]\
			local bghigh = colors[theme.promptHighlight]\
			if v:find(\"Back\") or v:find(\"Return\") then\
				bg = colors[theme.err]\
				bghigh = colors[theme.errHighlight]\
			end\
\
			if i == sel then term.setBackgroundColor(bghigh)\
			else term.setBackgroundColor(bg) end\
			term.setTextColor(colors[theme.textColor])\
			for x = -1, 1 do\
				term.setCursorPos(3, (i * 4) + x + 4)\
				term.write(string.rep(\" \", w - 13))\
			end\
\
			term.setCursorPos(3, i * 4 + 4)\
			if i == sel then\
				term.setBackgroundColor(bghigh)\
				term.write(\" > \")\
			else term.write(\" - \") end\
			term.write(v .. \" \")\
		end\
	end\
\
	local function updateDisplayList(items, loc, len)\
		local ret = {}\
		for i = 1, len do\
			local item = items[i + loc - 1]\
			if item then table.insert(ret, item) end\
		end\
		return ret\
	end\
\
	-- Variables\
	local sel = 1\
	local loc = 1\
	local len = 3\
	local disList = updateDisplayList(list, loc, len)\
	draw(disList, sel, loc)\
\
	-- Loop\
	while true do\
		local e, key, x, y = os.pullEvent()\
\
		if e == \"mouse_click\" then\
			for i, v in ipairs(disList) do\
				if x >= 3 and x <= w - 11 and y >= i * 4 + 3 and y <= i * 4 + 5 then return v end\
			end\
		elseif e == \"key\" and key == 200 then\
			if sel > 1 then\
				sel = sel - 1\
				draw(disList, sel, loc)\
			elseif loc > 1 then\
				loc = loc - 1\
				disList = updateDisplayList(list, loc, len)\
				draw(disList, sel, loc)\
			end\
		elseif e == \"key\" and key == 208 then\
			if sel < len then\
				sel = sel + 1\
				draw(disList, sel, loc)\
			elseif loc + len - 1 < #list then\
				loc = loc + 1\
				disList = updateDisplayList(list, loc, len)\
				draw(disList, sel, loc)\
			end\
		elseif e == \"mouse_scroll\" then\
			os.queueEvent(\"key\", key == -1 and 200 or 208)\
		elseif e == \"key\" and key == 28 then\
			return disList[sel]\
		end\
	end\
end\
\
function monitorKeyboardShortcuts()\
	local ta, tb = nil, nil\
	local allowChar = false\
	local shiftPressed = false\
	while true do\
		local event, char = os.pullEvent()\
		if event == \"key\" and (char == 42 or char == 52) then\
			shiftPressed = true\
			tb = os.startTimer(keyboardShortcutTimeout)\
		elseif event == \"key\" and (char == 29 or char == 157 or char == 219 or char == 220) then\
			allowEditorEvent = false\
			allowChar = true\
			ta = os.startTimer(keyboardShortcutTimeout)\
		elseif event == \"key\" and allowChar then\
			local name = nil\
			for k, v in pairs(keys) do\
				if v == char then\
					if shiftPressed then os.queueEvent(\"shortcut\", \"ctrl shift\", k:lower())\
					else os.queueEvent(\"shortcut\", \"ctrl\", k:lower()) end\
					sleep(0.005)\
					allowEditorEvent = true\
				end\
			end\
			if shiftPressed then os.queueEvent(\"shortcut\", \"ctrl shift\", char)\
			else os.queueEvent(\"shortcut\", \"ctrl\", char) end\
		elseif event == \"timer\" and char == ta then\
			allowEditorEvent = true\
			allowChar = false\
		elseif event == \"timer\" and char == tb then\
			shiftPressed = false\
		end\
	end\
end\
\
\
--  -------- Saving and Loading\
\
local function download(url, path)\
	for i = 1, 3 do\
		local response = http.get(url)\
		if response then\
			local data = response.readAll()\
			response.close()\
			if path then\
				local f = io.open(path, \"w\")\
				f:write(data)\
				f:close()\
			end\
			return true\
		end\
	end\
\
	return false\
end\
\
local function saveFile(path, lines)\
	local dir = path:sub(1, path:len() - fs.getName(path):len())\
	if not fs.exists(dir) then fs.makeDir(dir) end\
	if not fs.isDir(path) and not fs.isReadOnly(path) then\
		local a = \"\"\
		for _, v in pairs(lines) do a = a .. v .. \"\\n\" end\
\
		local f = io.open(path, \"w\")\
		f:write(a)\
		f:close()\
		return true\
	else return false end\
end\
\
local function loadFile(path)\
	if not fs.exists(path) then\
		local dir = path:sub(1, path:len() - fs.getName(path):len())\
		if not fs.exists(dir) then fs.makeDir(dir) end\
		local f = io.open(path, \"w\")\
		f:write(\"\")\
		f:close()\
	end\
\
	local l = {}\
	if fs.exists(path) and not fs.isDir(path) then\
		local f = io.open(path, \"r\")\
		if f then\
			local a = f:read(\"*l\")\
			while a do\
				table.insert(l, a)\
				a = f:read(\"*l\")\
			end\
			f:close()\
		end\
	else return nil end\
\
	if #l < 1 then table.insert(l, \"\") end\
	return l\
end\
\
\
--  -------- Languages\
\
languages.lua = {}\
languages.brainfuck = {}\
languages.none = {}\
\
--  Lua\
\
languages.lua.helpTips = {\
	\"A function you tried to call doesn't exist.\",\
	\"You made a typo.\",\
	\"The index of an array is nil.\",\
	\"The wrong variable type was passed.\",\
	\"A function/variable doesn't exist.\",\
	\"You missed an 'end'.\",\
	\"You missed a 'then'.\",\
	\"You declared a variable incorrectly.\",\
	\"One of your variables is mysteriously nil.\"\
}\
\
languages.lua.defaultHelpTips = {\
	2, 5\
}\
\
languages.lua.errors = {\
	[\"Attempt to call nil.\"] = {1, 2},\
	[\"Attempt to index nil.\"] = {3, 2},\
	[\".+ expected, got .+\"] = {4, 2, 9},\
	[\"'end' expected\"] = {6, 2},\
	[\"'then' expected\"] = {7, 2},\
	[\"'=' expected\"] = {8, 2}\
}\
\
languages.lua.keywords = {\
	[\"and\"] = \"conditional\",\
	[\"break\"] = \"conditional\",\
	[\"do\"] = \"conditional\",\
	[\"else\"] = \"conditional\",\
	[\"elseif\"] = \"conditional\",\
	[\"end\"] = \"conditional\",\
	[\"for\"] = \"conditional\",\
	[\"function\"] = \"conditional\",\
	[\"if\"] = \"conditional\",\
	[\"in\"] = \"conditional\",\
	[\"local\"] = \"conditional\",\
	[\"not\"] = \"conditional\",\
	[\"or\"] = \"conditional\",\
	[\"repeat\"] = \"conditional\",\
	[\"return\"] = \"conditional\",\
	[\"then\"] = \"conditional\",\
	[\"until\"] = \"conditional\",\
	[\"while\"] = \"conditional\",\
\
	[\"true\"] = \"constant\",\
	[\"false\"] = \"constant\",\
	[\"nil\"] = \"constant\",\
\
	[\"print\"] = \"function\",\
	[\"write\"] = \"function\",\
	[\"sleep\"] = \"function\",\
	[\"pairs\"] = \"function\",\
	[\"ipairs\"] = \"function\",\
	[\"loadstring\"] = \"function\",\
	[\"loadfile\"] = \"function\",\
	[\"dofile\"] = \"function\",\
	[\"rawset\"] = \"function\",\
	[\"rawget\"] = \"function\",\
	[\"setfenv\"] = \"function\",\
	[\"getfenv\"] = \"function\",\
}\
\
languages.lua.parseError = function(e)\
	local ret = {filename = \"unknown\", line = -1, display = \"Unknown!\", err = \"\"}\
	if e and e ~= \"\" then\
		ret.err = e\
		if e:find(\":\") then\
			ret.filename = e:sub(1, e:find(\":\") - 1):gsub(\"^%s*(.-)%s*$\", \"%1\")\
			-- The \"\" is needed to circumvent a CC bug\
			e = (e:sub(e:find(\":\") + 1) .. \"\"):gsub(\"^%s*(.-)%s*$\", \"%1\")\
			if e:find(\":\") then\
				ret.line = e:sub(1, e:find(\":\") - 1)\
				e = e:sub(e:find(\":\") + 2):gsub(\"^%s*(.-)%s*$\", \"%1\") .. \"\"\
			end\
		end\
		ret.display = e:sub(1, 1):upper() .. e:sub(2, -1) .. \".\"\
	end\
\
	return ret\
end\
\
languages.lua.getCompilerErrors = function(code)\
	code = \"local function ee65da6af1cb6f63fee9a081246f2fd92b36ef2(...)\\n\\n\" .. code .. \"\\n\\nend\"\
	local fn, err = loadstring(code)\
	if not err then\
		local _, e = pcall(fn)\
		if e then err = e end\
	end\
\
	if err then\
		local a = err:find(\"]\", 1, true)\
		if a then err = \"string\" .. err:sub(a + 1, -1) end\
		local ret = languages.lua.parseError(err)\
		if tonumber(ret.line) then ret.line = tonumber(ret.line) end\
		return ret\
	else return languages.lua.parseError(nil) end\
end\
\
languages.lua.run = function(path, ar)\
	local fn, err = loadfile(path)\
	setfenv(fn, getfenv())\
	if not err then\
		_, err = pcall(function() fn(unpack(ar)) end)\
	end\
	return err\
end\
\
\
--  Brainfuck\
\
languages.brainfuck.helpTips = {\
	\"Well idk...\",\
	\"Isn't this the whole point of the language?\",\
	\"Ya know... Not being able to debug it?\",\
	\"You made a typo.\"\
}\
\
languages.brainfuck.defaultHelpTips = {\
	1, 2, 3\
}\
\
languages.brainfuck.errors = {\
	[\"No matching '['\"] = {1, 2, 3, 4}\
}\
\
languages.brainfuck.keywords = {}\
\
languages.brainfuck.parseError = function(e)\
	local ret = {filename = \"unknown\", line = -1, display = \"Unknown!\", err = \"\"}\
	if e and e ~= \"\" then\
		ret.err = e\
		ret.line = e:sub(1, e:find(\":\") - 1)\
		e = e:sub(e:find(\":\") + 2):gsub(\"^%s*(.-)%s*$\", \"%1\") .. \"\"\
		ret.display = e:sub(1, 1):upper() .. e:sub(2, -1) .. \".\"\
	end\
\
	return ret\
end\
\
languages.brainfuck.mapLoops = function(code)\
	-- Map loops\
	local loopLocations = {}\
	local loc = 1\
	local line = 1\
	for let in string.gmatch(code, \".\") do\
		if let == \"[\" then\
			loopLocations[loc] = true\
		elseif let == \"]\" then\
			local found = false\
			for i = loc, 1, -1 do \
				if loopLocations[i] == true then\
					loopLocations[i] = loc\
					found = true\
				end\
			end\
\
			if not found then\
				return line .. \": No matching '['\"\
			end\
		end\
\
		if let == \"\\n\" then line = line + 1 end\
		loc = loc + 1\
	end\
	return loopLocations\
end\
\
languages.brainfuck.getCompilerErrors = function(code)\
	local a = languages.brainfuck.mapLoops(code)\
	if type(a) == \"string\" then return languages.brainfuck.parseError(a)\
	else return languages.brainfuck.parseError(nil) end\
end\
\
languages.brainfuck.run = function(path)\
	-- Read from file\
	local f = io.open(path, \"r\")\
	local content = f:read(\"*a\")\
	f:close()\
\
	-- Define environment\
	local dataCells = {}\
	local dataPointer = 1\
	local instructionPointer = 1\
\
	-- Map loops\
	local loopLocations = languages.brainfuck.mapLoops(content)\
	if type(loopLocations) == \"string\" then return loopLocations end\
\
	-- Execute code\
	while true do\
		local let = content:sub(instructionPointer, instructionPointer)\
\
		if let == \">\" then\
			dataPointer = dataPointer + 1\
			if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
		elseif let == \"<\" then\
			if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
			dataPointer = dataPointer - 1\
			if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
		elseif let == \"+\" then\
			if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
			dataCells[tostring(dataPointer)] = dataCells[tostring(dataPointer)] + 1\
		elseif let == \"-\" then\
			if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
			dataCells[tostring(dataPointer)] = dataCells[tostring(dataPointer)] - 1\
		elseif let == \".\" then\
			if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
			if term.getCursorPos() >= w then print(\"\") end\
			write(string.char(math.max(1, dataCells[tostring(dataPointer)])))\
		elseif let == \",\" then\
			if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
			term.setCursorBlink(true)\
			local e, but = os.pullEvent(\"char\")\
			term.setCursorBlink(false)\
			dataCells[tostring(dataPointer)] = string.byte(but)\
			if term.getCursorPos() >= w then print(\"\") end\
			write(but)\
		elseif let == \"/\" then\
			if not dataCells[tostring(dataPointer)] then dataCells[tostring(dataPointer)] = 0 end\
			if term.getCursorPos() >= w then print(\"\") end\
			write(dataCells[tostring(dataPointer)])\
		elseif let == \"[\" then\
			if dataCells[tostring(dataPointer)] == 0 then\
				for k, v in pairs(loopLocations) do\
					if k == instructionPointer then instructionPointer = v end\
				end\
			end\
		elseif let == \"]\" then\
			for k, v in pairs(loopLocations) do\
				if v == instructionPointer then instructionPointer = k - 1 end\
			end\
		end\
\
		instructionPointer = instructionPointer + 1\
		if instructionPointer > content:len() then print(\"\") break end\
	end\
end\
\
--  None\
\
languages.none.helpTips = {}\
languages.none.defaultHelpTips = {}\
languages.none.errors = {}\
languages.none.keywords = {}\
\
languages.none.parseError = function(err)\
	return {filename = \"\", line = -1, display = \"\", err = \"\"}\
end\
\
languages.none.getCompilerErrors = function(code)\
	return languages.none.parseError(nil)\
end\
\
languages.none.run = function(path) end\
\
\
-- Load language\
curLanguage = languages.lua\
\
\
--  -------- Run GUI\
\
local function viewErrorHelp(e)\
	title(\"LuaIDE - Error Help\")\
\
	local tips = nil\
	for k, v in pairs(curLanguage.errors) do\
		if e.display:find(k) then tips = v break end\
	end\
\
	term.setBackgroundColor(colors[theme.err])\
	for i = 6, 8 do\
		term.setCursorPos(5, i)\
		term.write(string.rep(\" \", 35))\
	end\
\
	term.setBackgroundColor(colors[theme.prompt])\
	for i = 10, 18 do\
		term.setCursorPos(5, i)\
		term.write(string.rep(\" \", 46))\
	end\
\
	if tips then\
		term.setBackgroundColor(colors[theme.err])\
		term.setCursorPos(6, 7)\
		term.write(\"Error Help\")\
\
		term.setBackgroundColor(colors[theme.prompt])\
		for i, v in ipairs(tips) do\
			term.setCursorPos(7, i + 10)\
			term.write(\"- \" .. curLanguage.helpTips[v])\
		end\
	else\
		term.setBackgroundColor(colors[theme.err])\
		term.setCursorPos(6, 7)\
		term.write(\"No Error Tips Available!\")\
\
		term.setBackgroundColor(colors[theme.prompt])\
		term.setCursorPos(6, 11)\
		term.write(\"There are no error tips available, but\")\
		term.setCursorPos(6, 12)\
		term.write(\"you could see if it was any of these:\")\
\
		for i, v in ipairs(curLanguage.defaultHelpTips) do\
			term.setCursorPos(7, i + 12)\
			term.write(\"- \" .. curLanguage.helpTips[v])\
		end\
	end\
\
	prompt({{\"Back\", w - 8, 7}}, \"horizontal\")\
end\
\
local function run(path, lines, useArgs)\
	local ar = {}\
	if useArgs then\
		title(\"LuaIDE - Run \" .. fs.getName(path))\
		local s = centerRead(w - 13, fs.getName(path) .. \" \")\
		for m in string.gmatch(s, \"[^ \\t]+\") do ar[#ar + 1] = m:gsub(\"^%s*(.-)%s*$\", \"%1\") end\
	end\
	\
	saveFile(path, lines)\
	term.setCursorBlink(false)\
	term.setBackgroundColor(colors.black)\
	term.setTextColor(colors.white)\
	term.clear()\
	term.setCursorPos(1, 1)\
	local err = curLanguage.run(path, ar)\
\
	term.setBackgroundColor(colors.black)\
	print(\"\\n\")\
	if err then\
		if isAdvanced() then term.setTextColor(colors.red) end\
		centerPrint(\"The program has crashed!\")\
	end\
	term.setTextColor(colors.white)\
	centerPrint(\"Press any key to return to LuaIDE...\")\
	while true do\
		local e = os.pullEvent()\
		if e == \"key\" then break end\
	end\
\
	-- To prevent key from showing up in editor\
	os.queueEvent(event_distract)\
	os.pullEvent()\
\
	if err then\
		if curLanguage == languages.lua and err:find(\"]\") then\
			err = fs.getName(path) .. err:sub(err:find(\"]\", 1, true) + 1, -1)\
		end\
\
		while true do\
			title(\"LuaIDE - Error!\")\
\
			term.setBackgroundColor(colors[theme.err])\
			for i = 6, 8 do\
				term.setCursorPos(3, i)\
				term.write(string.rep(\" \", w - 5))\
			end\
			term.setCursorPos(4, 7)\
			term.write(\"The program has crashed!\")\
\
			term.setBackgroundColor(colors[theme.prompt])\
			for i = 10, 14 do\
				term.setCursorPos(3, i)\
				term.write(string.rep(\" \", w - 5))\
			end\
\
			local formattedErr = curLanguage.parseError(err)\
			term.setCursorPos(4, 11)\
			term.write(\"Line: \" .. formattedErr.line)\
			term.setCursorPos(4, 12)\
			term.write(\"Error:\")\
			term.setCursorPos(5, 13)\
\
			local a = formattedErr.display\
			local b = nil\
			if a:len() > w - 8 then\
				for i = a:len(), 1, -1 do\
					if a:sub(i, i) == \" \" then\
						b = a:sub(i + 1, -1)\
						a = a:sub(1, i)\
						break\
					end\
				end\
			end\
\
			term.write(a)\
			if b then\
				term.setCursorPos(5, 14)\
				term.write(b)\
			end\
			\
			local opt = prompt({{\"Error Help\", w/2 - 15, 17}, {\"Go To Line\", w/2 + 2, 17}},\
				\"horizontal\")\
			if opt == \"Error Help\" then\
				viewErrorHelp(formattedErr)\
			elseif opt == \"Go To Line\" then\
				-- To prevent key from showing up in editor\
				os.queueEvent(event_distract)\
				os.pullEvent()\
\
				return \"go to\", tonumber(formattedErr.line)\
			end\
		end\
	end\
end\
\
\
--  -------- Functions\
\
local function goto()\
	term.setBackgroundColor(colors[theme.backgroundHighlight])\
	term.setCursorPos(2, 1)\
	term.clearLine()\
	term.write(\"Line: \")\
	local line = modRead({visibleLength = w - 2})\
\
	local num = tonumber(line)\
	if num and num > 0 then return num\
	else\
		term.setCursorPos(2, 1)\
		term.clearLine()\
		term.write(\"Not a line number!\")\
		sleep(1.6)\
		return nil\
	end\
end\
\
local function setsyntax()\
	local opts = {\
		\"[Lua]   Brainfuck    None \",\
		\" Lua   [Brainfuck]   None \",\
		\" Lua    Brainfuck   [None]\"\
	}\
	local sel = 1\
\
	term.setCursorBlink(false)\
	term.setBackgroundColor(colors[theme.backgroundHighlight])\
	term.setCursorPos(2, 1)\
	term.clearLine()\
	term.write(opts[sel])\
	while true do\
		local e, but, x, y = os.pullEvent(\"key\")\
		if but == 203 then\
			sel = math.max(1, sel - 1)\
			term.setCursorPos(2, 1)\
			term.clearLine()\
			term.write(opts[sel])\
		elseif but == 205 then\
			sel = math.min(#opts, sel + 1)\
			term.setCursorPos(2, 1)\
			term.clearLine()\
			term.write(opts[sel])\
		elseif but == 28 then\
			if sel == 1 then curLanguage = languages.lua\
			elseif sel == 2 then curLanguage = languages.brainfuck\
			elseif sel == 3 then curLanguage = languages.none end\
			term.setCursorBlink(true)\
			return\
		end\
	end\
end\
\
\
--  -------- Re-Indenting\
\
local tabWidth = 2\
\
local comments = {}\
local strings = {}\
\
local increment = {\
	\"if%s+.+%s+then%s*$\",\
	\"for%s+.+%s+do%s*$\",\
	\"while%s+.+%s+do%s*$\",\
	\"repeat%s*$\",\
	\"function%s+[a-zA-Z_0-9]\\(.*\\)%s*$\"\
}\
\
local decrement = {\
	\"end\",\
	\"until%s+.+\"\
}\
\
local special = {\
	\"else%s*$\",\
	\"elseif%s+.+%s+then%s*$\"\
}\
\
local function check(func)\
	for _, v in pairs(func) do\
		local cLineStart = v[\"lineStart\"]\
		local cLineEnd = v[\"lineEnd\"]\
		local cCharStart = v[\"charStart\"]\
		local cCharEnd = v[\"charEnd\"]\
\
		if line >= cLineStart and line <= cLineEnd then\
			if line == cLineStart then return cCharStart < charNumb\
			elseif line == cLineEnd then return cCharEnd > charNumb\
			else return true end\
		end\
	end\
end\
\
local function isIn(line, loc)\
	if check(comments) then return true end\
	if check(strings) then return true end\
	return false\
end\
\
local function setComment(ls, le, cs, ce)\
	comments[#comments + 1] = {}\
	comments[#comments].lineStart = ls\
	comments[#comments].lineEnd = le\
	comments[#comments].charStart = cs\
	comments[#comments].charEnd = ce\
end\
\
local function setString(ls, le, cs, ce)\
	strings[#strings + 1] = {}\
	strings[#strings].lineStart = ls\
	strings[#strings].lineEnd = le\
	strings[#strings].charStart = cs\
	strings[#strings].charEnd = ce\
end\
\
local function map(contents)\
	local inCom = false\
	local inStr = false\
\
	for i = 1, #contents do\
		if content[i]:find(\"%-%-%[%[\") and not inStr and not inCom then\
			local cStart = content[i]:find(\"%-%-%[%[\")\
			setComment(i, nil, cStart, nil)\
			inCom = true\
		elseif content[i]:find(\"%-%-%[=%[\") and not inStr and not inCom then\
			local cStart = content[i]:find(\"%-%-%[=%[\")\
			setComment(i, nil, cStart, nil)\
			inCom = true\
		elseif content[i]:find(\"%[%[\") and not inStr and not inCom then\
			local cStart = content[i]:find(\"%[%[\")\
			setString(i, nil, cStart, nil)\
			inStr = true\
		elseif content[i]:find(\"%[=%[\") and not inStr and not inCom then\
			local cStart = content[i]:find(\"%[=%[\")\
			setString(i, nil, cStart, nil)\
			inStr = true\
		end\
\
		if content[i]:find(\"%]%]\") and inStr and not inCom then\
			local cStart, cEnd = content[i]:find(\"%]%]\")\
			strings[#strings].lineEnd = i\
			strings[#strings].charEnd = cEnd\
			inStr = false\
		elseif content[i]:find(\"%]=%]\") and inStr and not inCom then\
			local cStart, cEnd = content[i]:find(\"%]=%]\")\
			strings[#strings].lineEnd = i\
			strings[#strings].charEnd = cEnd\
			inStr = false\
		end\
\
		if content[i]:find(\"%]%]\") and not inStr and inCom then\
			local cStart, cEnd = content[i]:find(\"%]%]\")\
			comments[#comments].lineEnd = i\
			comments[#comments].charEnd = cEnd\
			inCom = false\
		elseif content[i]:find(\"%]=%]\") and not inStr and inCom then\
			local cStart, cEnd = content[i]:find(\"%]=%]\")\
			comments[#comments].lineEnd = i\
			comments[#comments].charEnd = cEnd\
			inCom = false\
		end\
\
		if content[i]:find(\"%-%-\") and not inStr and not inCom then\
			local cStart = content[i]:find(\"%-%-\")\
			setComment(i, i, cStart, -1)\
		elseif content[i]:find(\"'\") and not inStr and not inCom then\
			local cStart, cEnd = content[i]:find(\"'\")\
			local nextChar = content[i]:sub(cEnd + 1, string.len(content[i]))\
			local _, cEnd = nextChar:find(\"'\")\
			setString(i, i, cStart, cEnd)\
		elseif content[i]:find('\"') and not inStr and not inCom then\
			local cStart, cEnd = content[i]:find('\"')\
			local nextChar = content[i]:sub(cEnd + 1, string.len(content[i]))\
			local _, cEnd = nextChar:find('\"')\
			setString(i, i, cStart, cEnd)\
		end\
	end\
end\
\
local function reindent(contents)\
	local err = nil\
	if curLanguage ~= languages.lua then\
		err = \"Cannot indent languages other than Lua!\"\
	elseif curLanguage.getCompilerErrors(table.concat(contents, \"\\n\")).line ~= -1 then\
		err = \"Cannot indent a program with errors!\"\
	end\
\
	if err then\
		term.setCursorBlink(false)\
		term.setCursorPos(2, 1)\
		term.setBackgroundColor(colors[theme.backgroundHighlight])\
		term.clearLine()\
		term.write(err)\
		sleep(1.6)\
		return contents\
	end\
\
	local new = {}\
	local level = 0\
	for k, v in pairs(contents) do\
		local incrLevel = false\
		local foundIncr = false\
		for _, incr in pairs(increment) do\
			if v:find(incr) and not isIn(k, v:find(incr)) then\
				incrLevel = true\
			end\
			if v:find(incr:sub(1, -2)) and not isIn(k, v:find(incr)) then\
				foundIncr = true\
			end\
		end\
\
		local decrLevel = false\
		if not incrLevel then\
			for _, decr in pairs(decrement) do\
				if v:find(decr) and not isIn(k, v:find(decr)) and not foundIncr then\
					level = math.max(0, level - 1)\
					decrLevel = true\
				end\
			end\
		end\
\
		if not decrLevel then\
			for _, sp in pairs(special) do\
				if v:find(sp) and not isIn(k, v:find(sp)) then\
					incrLevel = true\
					level = math.max(0, level - 1)\
				end\
			end\
		end\
\
		new[k] = string.rep(\" \", level * tabWidth) .. v\
		if incrLevel then level = level + 1 end\
	end\
\
	return new\
end\
\
\
--  -------- Menu\
\
local menu = {\
	[1] = {\"File\",\
--		\"About\",\
--		\"Settings\",\
--		\"\",\
		\"New File  ^+N\",\
		\"Open File ^+O\",\
		\"Save File ^+S\",\
		\"Close     ^+W\",\
		\"Print     ^+P\",\
		\"Quit      ^+Q\"\
	}, [2] = {\"Edit\",\
		\"Cut Line   ^+X\",\
		\"Copy Line  ^+C\",\
		\"Paste Line ^+V\",\
		\"Delete Line\",\
		\"Clear Line\"\
	}, [3] = {\"Functions\",\
		\"Go To Line    ^+G\",\
		\"Re-Indent     ^+I\",\
		\"Set Syntax    ^+E\",\
		\"Start of Line ^+<\",\
		\"End of Line   ^+>\"\
	}, [4] = {\"Run\",\
		\"Run Program       ^+R\",\
		\"Run w/ Args ^+Shift+R\"\
	}\
}\
\
local shortcuts = {\
	-- File\
	[\"ctrl n\"] = \"New File  ^+N\",\
	[\"ctrl o\"] = \"Open File ^+O\",\
	[\"ctrl s\"] = \"Save File ^+S\",\
	[\"ctrl w\"] = \"Close     ^+W\",\
	[\"ctrl p\"] = \"Print     ^+P\",\
	[\"ctrl q\"] = \"Quit      ^+Q\",\
\
	-- Edit\
	[\"ctrl x\"] = \"Cut Line   ^+X\",\
	[\"ctrl c\"] = \"Copy Line  ^+C\",\
	[\"ctrl v\"] = \"Paste Line ^+V\",\
\
	-- Functions\
	[\"ctrl g\"] = \"Go To Line    ^+G\",\
	[\"ctrl i\"] = \"Re-Indent     ^+I\",\
	[\"ctrl e\"] = \"Set Syntax    ^+E\",\
	[\"ctrl 203\"] = \"Start of Line ^+<\",\
	[\"ctrl 205\"] = \"End of Line   ^+>\",\
\
	-- Run\
	[\"ctrl r\"] = \"Run Program       ^+R\",\
	[\"ctrl shift r\"] = \"Run w/ Args ^+Shift+R\"\
}\
\
local menuFunctions = {\
	-- File\
--	[\"About\"] = function() end,\
--	[\"Settings\"] = function() end,\
	[\"New File  ^+N\"] = function(path, lines) saveFile(path, lines) return \"new\" end,\
	[\"Open File ^+O\"] = function(path, lines) saveFile(path, lines) return \"open\" end,\
	[\"Save File ^+S\"] = function(path, lines) saveFile(path, lines) end,\
	[\"Close     ^+W\"] = function(path, lines) saveFile(path, lines) return \"menu\" end,\
	[\"Print     ^+P\"] = function(path, lines) saveFile(path, lines) return nil end,\
	[\"Quit      ^+Q\"] = function(path, lines) saveFile(path, lines) return \"exit\" end,\
\
	-- Edit\
	[\"Cut Line   ^+X\"] = function(path, lines, y)\
		clipboard = lines[y] table.remove(lines, y) return nil, lines end,\
	[\"Copy Line  ^+C\"] = function(path, lines, y) clipboard = lines[y] end,\
	[\"Paste Line ^+V\"] = function(path, lines, y)\
		if clipboard then table.insert(lines, y, clipboard) end return nil, lines end,\
	[\"Delete Line\"] = function(path, lines, y) table.remove(lines, y) return nil, lines end,\
	[\"Clear Line\"] = function(path, lines, y) lines[y] = \"\" return nil, lines, \"cursor\" end,\
\
	-- Functions\
	[\"Go To Line    ^+G\"] = function() return nil, \"go to\", goto() end,\
	[\"Re-Indent     ^+I\"] = function(path, lines)\
		local a = reindent(lines) saveFile(path, lines) return nil, a\
	end,\
	[\"Set Syntax    ^+E\"] = function(path, lines)\
		setsyntax()\
		if curLanguage == languages.brainfuck and lines[1] ~= \"-- Syntax: Brainfuck\" then\
			table.insert(lines, 1, \"-- Syntax: Brainfuck\")\
			return nil, lines\
		end\
	end,\
	[\"Start of Line ^+<\"] = function() os.queueEvent(\"key\", 199) end,\
	[\"End of Line   ^+>\"] = function() os.queueEvent(\"key\", 207) end,\
\
	-- Run\
	[\"Run Program       ^+R\"] = function(path, lines)\
		saveFile(path, lines)\
		return nil, run(path, lines, false)\
	end,\
	[\"Run w/ Args ^+Shift+R\"] = function(path, lines)\
		saveFile(path, lines)\
		return nil, run(path, lines, true)\
	end,\
}\
\
local function drawMenu(open)\
	term.setCursorPos(1, 1)\
	term.setTextColor(colors[theme.textColor])\
	term.setBackgroundColor(colors[theme.backgroundHighlight])\
	term.clearLine()\
	local curX = 0\
	for _, v in pairs(menu) do\
		term.setCursorPos(3 + curX, 1)\
		term.write(v[1])\
		curX = curX + v[1]:len() + 3\
	end\
\
	if open then\
		local it = {}\
		local x = 1\
		for _, v in pairs(menu) do\
			if open == v[1] then\
				it = v\
				break\
			end\
			x = x + v[1]:len() + 3\
		end\
		x = x + 1\
\
		local items = {}\
		for i = 2, #it do\
			table.insert(items, it[i])\
		end\
\
		local len = 1\
		for _, v in pairs(items) do if v:len() + 2 > len then len = v:len() + 2 end end\
\
		for i, v in ipairs(items) do\
			term.setCursorPos(x, i + 1)\
			term.write(string.rep(\" \", len))\
			term.setCursorPos(x + 1, i + 1)\
			term.write(v)\
		end\
		term.setCursorPos(x, #items + 2)\
		term.write(string.rep(\" \", len))\
		return items, len\
	end\
end\
\
local function triggerMenu(cx, cy)\
	-- Determine clicked menu\
	local curX = 0\
	local open = nil\
	for _, v in pairs(menu) do\
		if cx >= curX + 3 and cx <= curX + v[1]:len() + 2 then\
			open = v[1]\
			break\
		end\
		curX = curX + v[1]:len() + 3\
	end\
	local menux = curX + 2\
	if not open then return false end\
\
	-- Flash menu item\
	term.setCursorBlink(false)\
	term.setCursorPos(menux, 1)\
	term.setBackgroundColor(colors[theme.background])\
	term.write(string.rep(\" \", open:len() + 2))\
	term.setCursorPos(menux + 1, 1)\
	term.write(open)\
	sleep(0.1)\
	local items, len = drawMenu(open)\
\
	local ret = true\
\
	-- Pull events on menu\
	local ox, oy = term.getCursorPos()\
	while type(ret) ~= \"string\" do\
		local e, but, x, y = os.pullEvent()\
		if e == \"mouse_click\" then\
			-- If clicked outside menu\
			if x < menux - 1 or x > menux + len - 1 then break\
			elseif y > #items + 2 then break\
			elseif y == 1 then break end\
\
			for i, v in ipairs(items) do\
				if y == i + 1 and x >= menux and x <= menux + len - 2 then\
					-- Flash when clicked\
					term.setCursorPos(menux, y)\
					term.setBackgroundColor(colors[theme.background])\
					term.write(string.rep(\" \", len))\
					term.setCursorPos(menux + 1, y)\
					term.write(v)\
					sleep(0.1)\
					drawMenu(open)\
\
					-- Return item\
					ret = v\
					break\
				end\
			end\
		end\
	end\
\
	term.setCursorPos(ox, oy)\
	term.setCursorBlink(true)\
	return ret\
end\
\
\
--  -------- Editing\
\
local standardsCompletions = {\
	\"if%s+.+%s+then%s*$\",\
	\"for%s+.+%s+do%s*$\",\
	\"while%s+.+%s+do%s*$\",\
	\"repeat%s*$\",\
	\"function%s+[a-zA-Z_0-9]?\\(.*\\)%s*$\",\
	\"=%s*function%s*\\(.*\\)%s*$\",\
	\"else%s*$\",\
	\"elseif%s+.+%s+then%s*$\"\
}\
\
local liveCompletions = {\
	[\"(\"] = \")\",\
	[\"{\"] = \"}\",\
	[\"[\"] = \"]\",\
	[\"\\\"\"] = \"\\\"\",\
	[\"'\"] = \"'\",\
}\
\
local x, y = 0, 0\
local edw, edh = 0, h - 1\
local offx, offy = 0, 1\
local scrollx, scrolly = 0, 0\
local lines = {}\
local liveErr = curLanguage.parseError(nil)\
local displayCode = true\
local lastEventClock = os.clock()\
\
local function attemptToHighlight(line, regex, col)\
	local match = string.match(line, regex)\
	if match then\
		if type(col) == \"number\" then term.setTextColor(col)\
		elseif type(col) == \"function\" then term.setTextColor(col(match)) end\
		term.write(match)\
		term.setTextColor(colors[theme.textColor])\
		return line:sub(match:len() + 1, -1)\
	end\
	return nil\
end\
\
local function writeHighlighted(line)\
	if curLanguage == languages.lua then\
		while line:len() > 0 do	\
			line = attemptToHighlight(line, \"^%-%-%[%[.-%]%]\", colors[theme.comment]) or\
				attemptToHighlight(line, \"^%-%-.*\", colors[theme.comment]) or\
				attemptToHighlight(line, \"^\\\".*[^\\\\]\\\"\", colors[theme.string]) or\
				attemptToHighlight(line, \"^\\'.*[^\\\\]\\'\", colors[theme.string]) or\
				attemptToHighlight(line, \"^%[%[.-%]%]\", colors[theme.string]) or\
				attemptToHighlight(line, \"^[%w_]+\", function(match)\
					if curLanguage.keywords[match] then\
						return colors[theme[curLanguage.keywords[match]]]\
					end\
					return colors[theme.textColor]\
				end) or\
				attemptToHighlight(line, \"^[^%w_]\", colors[theme.textColor])\
		end\
	else term.write(line) end\
end\
\
local function draw()\
	-- Menu\
	term.setTextColor(colors[theme.textColor])\
	term.setBackgroundColor(colors[theme.editorBackground])\
	term.clear()\
	drawMenu()\
\
	-- Line numbers\
	offx, offy = tostring(#lines):len() + 1, 1\
	edw, edh = w - offx, h - 1\
\
	-- Draw text\
	for i = 1, edh do\
		local a = lines[scrolly + i]\
		if a then\
			local ln = string.rep(\" \", offx - 1 - tostring(scrolly + i):len()) .. tostring(scrolly + i) \
			local l = a:sub(scrollx + 1, edw + scrollx + 1)\
			ln = ln .. \":\"\
\
			if liveErr.line == scrolly + i then ln = string.rep(\" \", offx - 2) .. \"!:\" end\
\
			term.setCursorPos(1, i + offy)\
			term.setBackgroundColor(colors[theme.editorBackground])\
			if scrolly + i == y then\
				if scrolly + i == liveErr.line and os.clock() - lastEventClock > 3 then\
					term.setBackgroundColor(colors[theme.editorErrorHighlight])\
				else term.setBackgroundColor(colors[theme.editorLineHightlight]) end\
				term.clearLine()\
			elseif scrolly + i == liveErr.line then\
				term.setBackgroundColor(colors[theme.editorError])\
				term.clearLine()\
			end\
\
			term.setCursorPos(1 - scrollx + offx, i + offy)\
			if scrolly + i == y then\
				if scrolly + i == liveErr.line and os.clock() - lastEventClock > 3 then\
					term.setBackgroundColor(colors[theme.editorErrorHighlight])\
				else term.setBackgroundColor(colors[theme.editorLineHightlight]) end\
			elseif scrolly + i == liveErr.line then term.setBackgroundColor(colors[theme.editorError])\
			else term.setBackgroundColor(colors[theme.editorBackground]) end\
			if scrolly + i == liveErr.line then\
				if displayCode then term.write(a)\
				else term.write(liveErr.display) end\
			else writeHighlighted(a) end\
\
			term.setCursorPos(1, i + offy)\
			if scrolly + i == y then\
				if scrolly + i == liveErr.line and os.clock() - lastEventClock > 3 then\
					term.setBackgroundColor(colors[theme.editorError])\
				else term.setBackgroundColor(colors[theme.editorLineNumbersHighlight]) end\
			elseif scrolly + i == liveErr.line then\
				term.setBackgroundColor(colors[theme.editorErrorHighlight])\
			else term.setBackgroundColor(colors[theme.editorLineNumbers]) end\
			term.write(ln)\
		end\
	end\
	term.setCursorPos(x - scrollx + offx, y - scrolly + offy)\
end\
\
local function drawLine(...)\
	local ls = {...}\
	offx = tostring(#lines):len() + 1\
	for _, ly in pairs(ls) do\
		local a = lines[ly]\
		if a then\
			local ln = string.rep(\" \", offx - 1 - tostring(ly):len()) .. tostring(ly) \
			local l = a:sub(scrollx + 1, edw + scrollx + 1)\
			ln = ln .. \":\"\
\
			if liveErr.line == ly then ln = string.rep(\" \", offx - 2) .. \"!:\" end\
\
			term.setCursorPos(1, (ly - scrolly) + offy)\
			term.setBackgroundColor(colors[theme.editorBackground])\
			if ly == y then\
				if ly == liveErr.line and os.clock() - lastEventClock > 3 then\
					term.setBackgroundColor(colors[theme.editorErrorHighlight])\
				else term.setBackgroundColor(colors[theme.editorLineHightlight]) end\
			elseif ly == liveErr.line then\
				term.setBackgroundColor(colors[theme.editorError])\
			end\
			term.clearLine()\
\
			term.setCursorPos(1 - scrollx + offx, (ly - scrolly) + offy)\
			if ly == y then\
				if ly == liveErr.line and os.clock() - lastEventClock > 3 then\
					term.setBackgroundColor(colors[theme.editorErrorHighlight])\
				else term.setBackgroundColor(colors[theme.editorLineHightlight]) end\
			elseif ly == liveErr.line then term.setBackgroundColor(colors[theme.editorError])\
			else term.setBackgroundColor(colors[theme.editorBackground]) end\
			if ly == liveErr.line then\
				if displayCode then term.write(a)\
				else term.write(liveErr.display) end\
			else writeHighlighted(a) end\
\
			term.setCursorPos(1, (ly - scrolly) + offy)\
			if ly == y then\
				if ly == liveErr.line and os.clock() - lastEventClock > 3 then\
					term.setBackgroundColor(colors[theme.editorError])\
				else term.setBackgroundColor(colors[theme.editorLineNumbersHighlight]) end\
			elseif ly == liveErr.line then\
				term.setBackgroundColor(colors[theme.editorErrorHighlight])\
			else term.setBackgroundColor(colors[theme.editorLineNumbers]) end\
			term.write(ln)\
		end\
	end\
	term.setCursorPos(x - scrollx + offx, y - scrolly + offy)\
end\
\
local function cursorLoc(x, y, force)\
	local sx, sy = x - scrollx, y - scrolly\
	local redraw = false\
	if sx < 1 then\
		scrollx = x - 1\
		sx = 1\
		redraw = true\
	elseif sx > edw then\
		scrollx = x - edw\
		sx = edw\
		redraw = true\
	end if sy < 1 then\
		scrolly = y - 1\
		sy = 1\
		redraw = true\
	elseif sy > edh then\
		scrolly = y - edh\
		sy = edh\
		redraw = true\
	end if redraw or force then draw() end\
	term.setCursorPos(sx + offx, sy + offy)\
end\
\
local function executeMenuItem(a, path)\
	if type(a) == \"string\" and menuFunctions[a] then\
		local opt, nl, gtln = menuFunctions[a](path, lines, y)\
		if type(opt) == \"string\" then term.setCursorBlink(false) return opt end\
		if type(nl) == \"table\" then\
			if #lines < 1 then table.insert(lines, \"\") end\
			y = math.min(y, #lines)\
			x = math.min(x, lines[y]:len() + 1)\
			lines = nl\
		elseif type(nl) == \"string\" then\
			if nl == \"go to\" and gtln then\
				x, y = 1, math.min(#lines, gtln)\
				cursorLoc(x, y)\
			end\
		end\
	end\
	term.setCursorBlink(true)\
	draw()\
	term.setCursorPos(x - scrollx + offx, y - scrolly + offy)\
end\
\
local function edit(path)\
	-- Variables\
	x, y = 1, 1\
	offx, offy = 0, 1\
	scrollx, scrolly = 0, 0\
	lines = loadFile(path)\
	if not lines then return \"menu\" end\
\
	-- Enable brainfuck\
	if lines[1] == \"-- Syntax: Brainfuck\" then\
		curLanguage = languages.brainfuck\
	end\
\
	-- Clocks\
	local autosaveClock = os.clock()\
	local scrollClock = os.clock() -- To prevent redraw flicker\
	local liveErrorClock = os.clock()\
	local hasScrolled = false\
\
	-- Draw\
	draw()\
	term.setCursorPos(x + offx, y + offy)\
	term.setCursorBlink(true)\
	\
	-- Main loop\
	local tid = os.startTimer(3)\
	while true do\
		local e, key, cx, cy = os.pullEvent()\
		if e == \"key\" and allowEditorEvent then\
			if key == 200 and y > 1 then\
				-- Up\
				x, y = math.min(x, lines[y - 1]:len() + 1), y - 1\
				drawLine(y, y + 1)\
				cursorLoc(x, y)\
			elseif key == 208 and y < #lines then\
				-- Down\
				x, y = math.min(x, lines[y + 1]:len() + 1), y + 1\
				drawLine(y, y - 1)\
				cursorLoc(x, y)\
			elseif key == 203 and x > 1 then\
				-- Left\
				x = x - 1\
				local force = false\
				if y - scrolly + offy < offy + 1 then force = true end\
				cursorLoc(x, y, force)\
			elseif key == 205 and x < lines[y]:len() + 1 then\
				-- Right\
				x = x + 1\
				local force = false\
				if y - scrolly + offy < offy + 1 then force = true end\
				cursorLoc(x, y, force)\
			elseif (key == 28 or key == 156) and (displayCode and true or y + scrolly - 1 ==\
					liveErr.line) then\
				-- Enter\
				local f = nil\
				for _, v in pairs(standardsCompletions) do\
					if lines[y]:find(v) then f = v end\
				end\
\
				local _, spaces = lines[y]:find(\"^[ ]+\")\
				if not spaces then spaces = 0 end\
				if f then\
					table.insert(lines, y + 1, string.rep(\" \", spaces + 2))\
					if not f:find(\"else\", 1, true) and not f:find(\"elseif\", 1, true) then\
						table.insert(lines, y + 2, string.rep(\" \", spaces) .. \
							(f:find(\"repeat\", 1, true) and \"until \" or f:find(\"{\", 1, true) and \"}\" or \
							\"end\"))\
					end\
					x, y = spaces + 3, y + 1\
					cursorLoc(x, y, true)\
				else\
					local oldLine = lines[y]\
\
					lines[y] = lines[y]:sub(1, x - 1)\
					table.insert(lines, y + 1, string.rep(\" \", spaces) .. oldLine:sub(x, -1))\
\
					x, y = spaces + 1, y + 1\
					cursorLoc(x, y, true)\
				end\
			elseif key == 14 and (displayCode and true or y + scrolly - 1 == liveErr.line) then\
				-- Backspace\
				if x > 1 then\
					local f = false\
					for k, v in pairs(liveCompletions) do\
						if lines[y]:sub(x - 1, x - 1) == k then f = true end\
					end\
\
					lines[y] = lines[y]:sub(1, x - 2) .. lines[y]:sub(x + (f and 1 or 0), -1)\
					drawLine(y)\
					x = x - 1\
					cursorLoc(x, y)\
				elseif y > 1 then\
					local prevLen = lines[y - 1]:len() + 1\
					lines[y - 1] = lines[y - 1] .. lines[y]\
					table.remove(lines, y)\
					x, y = prevLen, y - 1\
					cursorLoc(x, y, true)\
				end\
			elseif key == 199 then\
				-- Home\
				x = 1\
				local force = false\
				if y - scrolly + offy < offy + 1 then force = true end\
				cursorLoc(x, y, force)\
			elseif key == 207 then\
				-- End\
				x = lines[y]:len() + 1\
				local force = false\
				if y - scrolly + offy < offy + 1 then force = true end\
				cursorLoc(x, y, force)\
			elseif key == 211 and (displayCode and true or y + scrolly - 1 == liveErr.line) then\
				-- Forward Delete\
				if x < lines[y]:len() + 1 then\
					lines[y] = lines[y]:sub(1, x - 1) .. lines[y]:sub(x + 1)\
					local force = false\
					if y - scrolly + offy < offy + 1 then force = true end\
					drawLine(y)\
					cursorLoc(x, y, force)\
				elseif y < #lines then\
					lines[y] = lines[y] .. lines[y + 1]\
					table.remove(lines, y + 1)\
					draw()\
					cursorLoc(x, y)\
				end\
			elseif key == 15 and (displayCode and true or y + scrolly - 1 == liveErr.line) then\
				-- Tab\
				lines[y] = string.rep(\" \", tabWidth) .. lines[y]\
				x = x + 2\
				local force = false\
				if y - scrolly + offy < offy + 1 then force = true end\
				drawLine(y)\
				cursorLoc(x, y, force)\
			elseif key == 201 then\
				-- Page up\
				y = math.min(math.max(y - edh, 1), #lines)\
				x = math.min(lines[y]:len() + 1, x)\
				cursorLoc(x, y, true)\
			elseif key == 209 then\
				-- Page down\
				y = math.min(math.max(y + edh, 1), #lines)\
				x = math.min(lines[y]:len() + 1, x)\
				cursorLoc(x, y, true)\
			end\
		elseif e == \"char\" and allowEditorEvent and (displayCode and true or \
				y + scrolly - 1 == liveErr.line) then\
			local shouldIgnore = false\
			for k, v in pairs(liveCompletions) do\
				if key == v and lines[y]:find(k, 1, true) and lines[y]:sub(x, x) == v then\
					shouldIgnore = true\
				end\
			end\
\
			local addOne = false\
			if not shouldIgnore then\
				for k, v in pairs(liveCompletions) do\
					if key == k and lines[y]:sub(x, x) ~= k then key = key .. v addOne = true end\
				end\
				lines[y] = lines[y]:sub(1, x - 1) .. key .. lines[y]:sub(x, -1)\
			end\
\
			x = x + (addOne and 1 or key:len())\
			local force = false\
			if y - scrolly + offy < offy + 1 then force = true end\
			drawLine(y)\
			cursorLoc(x, y, force)\
		elseif e == \"mouse_click\" and key == 1 then\
			if cy > 1 then\
				if cx <= offx and cy - offy == liveErr.line - scrolly then\
					displayCode = not displayCode\
					drawLine(liveErr.line)\
				else\
					local oldy = y\
					y = math.min(math.max(scrolly + cy - offy, 1), #lines)\
					x = math.min(math.max(scrollx + cx - offx, 1), lines[y]:len() + 1)\
					if oldy ~= y then drawLine(oldy, y) end\
					cursorLoc(x, y)\
				end\
			else\
				local a = triggerMenu(cx, cy)\
				if a then\
					local opt = executeMenuItem(a, path)\
					if opt then return opt end\
				end\
			end\
		elseif e == \"shortcut\" then\
			local a = shortcuts[key .. \" \" .. cx]\
			if a then\
				local parent = nil\
				local curx = 0\
				for i, mv in ipairs(menu) do\
					for _, iv in pairs(mv) do\
						if iv == a then\
							parent = menu[i][1]\
							break\
						end\
					end\
					if parent then break end\
					curx = curx + mv[1]:len() + 3\
				end\
				local menux = curx + 2\
\
				-- Flash menu item\
				term.setCursorBlink(false)\
				term.setCursorPos(menux, 1)\
				term.setBackgroundColor(colors[theme.background])\
				term.write(string.rep(\" \", parent:len() + 2))\
				term.setCursorPos(menux + 1, 1)\
				term.write(parent)\
				sleep(0.1)\
				drawMenu()\
\
				-- Execute item\
				local opt = executeMenuItem(a, path)\
				if opt then return opt end\
			end\
		elseif e == \"mouse_scroll\" then\
			if key == -1 and scrolly > 0 then\
				scrolly = scrolly - 1\
				if os.clock() - scrollClock > 0.0005 then\
					draw()\
					term.setCursorPos(x - scrollx + offx, y - scrolly + offy)\
				end\
				scrollClock = os.clock()\
				hasScrolled = true\
			elseif key == 1 and scrolly < #lines - edh then\
				scrolly = scrolly + 1\
				if os.clock() - scrollClock > 0.0005 then\
					draw()\
					term.setCursorPos(x - scrollx + offx, y - scrolly + offy)\
				end\
				scrollClock = os.clock()\
				hasScrolled = true\
			end\
		elseif e == \"timer\" and key == tid then\
			drawLine(y)\
			tid = os.startTimer(3)\
		end\
\
		-- Draw\
		if hasScrolled and os.clock() - scrollClock > 0.1 then\
			draw()\
			term.setCursorPos(x - scrollx + offx, y - scrolly + offy)\
			hasScrolled = false\
		end\
\
		-- Autosave\
		if os.clock() - autosaveClock > autosaveInterval then\
			saveFile(path, lines)\
			autosaveClock = os.clock()\
		end\
\
		-- Errors\
		if os.clock() - liveErrorClock > 1 then\
			local prevLiveErr = liveErr\
			liveErr = curLanguage.parseError(nil)\
			local code = \"\"\
			for _, v in pairs(lines) do code = code .. v .. \"\\n\" end\
\
			liveErr = curLanguage.getCompilerErrors(code)\
			liveErr.line = math.min(liveErr.line - 2, #lines)\
			if liveErr ~= prevLiveErr then draw() end\
			liveErrorClock = os.clock()\
		end\
	end\
\
	return \"menu\"\
end\
\
\
--  -------- Open File\
\
local function newFile()\
	local wid = w - 13\
\
	-- Get name\
	title(\"Lua IDE - New File\")\
	local name = centerRead(wid, \"/\")\
	if not name or name == \"\" then return \"menu\" end\
	name = \"/\" .. name\
\
	-- Clear\
	title(\"Lua IDE - New File\")\
	term.setTextColor(colors[theme.textColor])\
	term.setBackgroundColor(colors[theme.promptHighlight])\
	for i = 8, 10 do\
		term.setCursorPos(w/2 - wid/2, i)\
		term.write(string.rep(\" \", wid))\
	end\
	term.setCursorPos(1, 9)\
	if fs.isDir(name) then\
		centerPrint(\"Cannot Edit a Directory!\")\
		sleep(1.6)\
		return \"menu\"\
	elseif fs.exists(name) then\
		centerPrint(\"File Already Exists!\")\
		local opt = prompt({{\"Open\", w/2 - 9, 14}, {\"Cancel\", w/2 + 2, 14}}, \"horizontal\")\
		if opt == \"Open\" then return \"edit\", name\
		elseif opt == \"Cancel\" then return \"menu\" end\
	else return \"edit\", name end\
end\
\
local function openFile()\
	local wid = w - 13\
\
	-- Get name\
	title(\"Lua IDE - Open File\")\
	local name = centerRead(wid, \"/\")\
	if not name or name == \"\" then return \"menu\" end\
	name = \"/\" .. name\
\
	-- Clear\
	title(\"Lua IDE - New File\")\
	term.setTextColor(colors[theme.textColor])\
	term.setBackgroundColor(colors[theme.promptHighlight])\
	for i = 8, 10 do\
		term.setCursorPos(w/2 - wid/2, i)\
		term.write(string.rep(\" \", wid))\
	end\
	term.setCursorPos(1, 9)\
	if fs.isDir(name) then\
		centerPrint(\"Cannot Open a Directory!\")\
		sleep(1.6)\
		return \"menu\"\
	elseif not fs.exists(name) then\
		centerPrint(\"File Doesn't Exist!\")\
		local opt = prompt({{\"Create\", w/2 - 11, 14}, {\"Cancel\", w/2 + 2, 14}}, \"horizontal\")\
		if opt == \"Create\" then return \"edit\", name\
		elseif opt == \"Cancel\" then return \"menu\" end\
	else return \"edit\", name end\
end\
\
\
--  -------- Settings\
\
local function update()\
	local function draw(status)\
		title(\"LuaIDE - Update\")\
		term.setBackgroundColor(colors[theme.prompt])\
		term.setTextColor(colors[theme.textColor])\
		for i = 8, 10 do\
			term.setCursorPos(w/2 - (status:len() + 4), i)\
			write(string.rep(\" \", status:len() + 4))\
		end\
		term.setCursorPos(w/2 - (status:len() + 4), 9)\
		term.write(\" - \" .. status .. \" \")\
\
		term.setBackgroundColor(colors[theme.errHighlight])\
		for i = 8, 10 do\
			term.setCursorPos(w/2 + 2, i)\
			term.write(string.rep(\" \", 10))\
		end\
		term.setCursorPos(w/2 + 2, 9)\
		term.write(\" > Cancel \")\
	end\
\
	if not http then\
		draw(\"HTTP API Disabled!\")\
		sleep(1.6)\
		return \"settings\"\
	end\
\
	draw(\"Updating...\")\
	local tID = os.startTimer(10)\
	http.request(updateURL)\
	while true do\
		local e, but, x, y = os.pullEvent()\
		if (e == \"key\" and but == 28) or\
				(e == \"mouse_click\" and x >= w/2 + 2 and x <= w/2 + 12 and y == 9) then\
			draw(\"Cancelled\")\
			sleep(1.6)\
			break\
		elseif e == \"http_success\" and but == updateURL then\
			local new = x.readAll()\
			local curf = io.open(ideLocation, \"r\")\
			local cur = curf:read(\"*a\")\
			curf:close()\
\
			if cur ~= new then\
				draw(\"Update Found\")\
				sleep(1.6)\
				local f = io.open(ideLocation, \"w\")\
				f:write(new)\
				f:close()\
\
				draw(\"Click to Exit\")\
				while true do\
					local e = os.pullEvent()\
					if e == \"mouse_click\" or (not isAdvanced() and e == \"key\") then break end\
				end\
				return \"exit\"\
			else\
				draw(\"No Updates Found!\")\
				sleep(1.6)\
				break\
			end\
		elseif e == \"http_failure\" or (e == \"timer\" and but == tID) then\
			draw(\"Update Failed!\")\
			sleep(1.6)\
			break\
		end\
	end\
\
	return \"settings\"\
end\
\
local function changeTheme()\
	title(\"LuaIDE - Theme\")\
\
	if isAdvanced() then\
		local disThemes = {\"Back\"}\
		for _, v in pairs(availableThemes) do table.insert(disThemes, v[1]) end\
		local t = scrollingPrompt(disThemes)\
		local url = nil\
		for _, v in pairs(availableThemes) do if v[1] == t then url = v[2] end end\
\
		if not url then return \"settings\" end\
		if t == \"Dawn (Default)\" then\
			term.setBackgroundColor(colors[theme.backgroundHighlight])\
			term.setCursorPos(3, 3)\
			term.clearLine()\
			term.write(\"LuaIDE - Loaded Theme!\")\
			sleep(1.6)\
\
			fs.delete(themeLocation)\
			theme = defaultTheme\
			return \"menu\"\
		end\
\
		term.setBackgroundColor(colors[theme.backgroundHighlight])\
		term.setCursorPos(3, 3)\
		term.clearLine()\
		term.write(\"LuaIDE - Downloading...\")\
\
		fs.delete(\"/.LuaIDE_temp_theme_file\")\
		download(url, \"/.LuaIDE_temp_theme_file\")\
		local a = loadTheme(\"/.LuaIDE_temp_theme_file\")\
\
		term.setCursorPos(3, 3)\
		term.clearLine()\
		if a then\
			term.write(\"LuaIDE - Loaded Theme!\")\
			fs.delete(themeLocation)\
			fs.move(\"/.LuaIDE_temp_theme_file\", themeLocation)\
			theme = a\
			sleep(1.6)\
			return \"menu\"\
		end\
		\
		term.write(\"LuaIDE - Could Not Load Theme!\")\
		fs.delete(\"/.LuaIDE_temp_theme_file\")\
		sleep(1.6)\
		return \"settings\"\
	else\
		term.setCursorPos(1, 8)\
		centerPrint(\"Themes are not available on\")\
		centerPrint(\"normal computers!\")\
	end\
end\
\
local function settings()\
	title(\"LuaIDE - Settings\")\
\
	local opt = prompt({{\"Change Theme\", w/2 - 17, 8}, {\"Return to Menu\", w/2 - 22, 13},\
		{\"Check for Updates\", w/2 + 2, 8}, {\"Exit IDE\", w/2 + 2, 13, bg = colors[theme.err], \
		highlight = colors[theme.errHighlight]}}, \"vertical\", true)\
	if opt == \"Change Theme\" then return changeTheme()\
	elseif opt == \"Check for Updates\" then return update()\
	elseif opt == \"Return to Menu\" then return \"menu\"\
	elseif opt == \"Exit IDE\" then return \"exit\" end\
end\
\
\
--  -------- Menu\
\
local function menu()\
	title(\"Welcome to LuaIDE \" .. version)\
\
	local opt = prompt({{\"New File\", w/2 - 13, 8}, {\"Open File\", w/2 - 14, 13},\
		{\"Settings\", w/2 + 2, 8}, {\"Exit IDE\", w/2 + 2, 13, bg = colors[theme.err],\
		highlight = colors[theme.errHighlight]}}, \"vertical\", true)\
	if opt == \"New File\" then return \"new\"\
	elseif opt == \"Open File\" then return \"open\"\
	elseif opt == \"Settings\" then return \"settings\"\
	elseif opt == \"Exit IDE\" then return \"exit\" end\
end\
\
\
--  -------- Main\
\
local function main(arguments)\
	local opt, data = \"menu\", nil\
\
	-- Check arguments\
	if type(arguments) == \"table\" and #arguments > 0 then\
		local f = \"/\" .. shell.resolve(arguments[1])\
		if fs.isDir(f) then print(\"Cannot edit a directory.\") end\
		opt, data = \"edit\", f\
	end\
\
	-- Main run loop\
	while true do\
		-- Menu\
		if opt == \"menu\" then opt = menu() end\
\
		-- Other\
		if opt == \"new\" then opt, data = newFile()\
		elseif opt == \"open\" then opt, data = openFile()\
		elseif opt == \"settings\" then opt = settings()\
		end if opt == \"exit\" then break end\
\
		-- Edit\
		if opt == \"edit\" and data then opt = edit(data) end\
	end\
end\
\
-- Load Theme\
if fs.exists(themeLocation) then theme = loadTheme(themeLocation) end\
if not theme and isAdvanced() then theme = defaultTheme\
elseif not theme then theme = normalTheme end\
\
-- Run\
local _, err = pcall(function()\
	parallel.waitForAny(function() main(args) end, monitorKeyboardShortcuts)\
end)\
\
-- Catch errors\
if err and not err:find(\"Terminated\") then\
	term.setCursorBlink(false)\
	title(\"LuaIDE - Crash! D:\")\
\
	term.setBackgroundColor(colors[theme.err])\
	for i = 6, 8 do\
		term.setCursorPos(5, i)\
		term.write(string.rep(\" \", 36))\
	end\
	term.setCursorPos(6, 7)\
	term.write(\"LuaIDE Has Crashed! D:\")\
\
	term.setBackgroundColor(colors[theme.background])\
	term.setCursorPos(2, 10)\
	print(err)\
\
	term.setBackgroundColor(colors[theme.prompt])\
	local _, cy = term.getCursorPos()\
	for i = cy + 1, cy + 4 do\
		term.setCursorPos(5, i)\
		term.write(string.rep(\" \", 36))\
	end\
	term.setCursorPos(6, cy + 2)\
	term.write(\"Please report this error to\")\
	term.setCursorPos(6, cy + 3)\
	term.write(\"GravityScore! \")\
	\
	term.setBackgroundColor(colors[theme.background])\
	if isAdvanced() then centerPrint(\"Click to Exit...\", h - 1)\
	else centerPrint(\"Press Any Key to Exit...\", h - 1) end\
	while true do\
		local e = os.pullEvent()\
		if e == \"mouse_click\" or (not isAdvanced() and e == \"key\") then break end\
	end\
\
	-- Prevent key from being shown\
	os.queueEvent(event_distract)\
	os.pullEvent()\
end\
\
-- Exit\
term.setBackgroundColor(colors.black)\
term.setTextColor(colors.white)\
term.clear()\
term.setCursorPos(1, 1)\
centerPrint(\"Thank You for Using Lua IDE \" .. version)\
centerPrint(\"Made by GravityScore\")",
    [ "sys/apps/OpusUI" ] = "local GIT_REPO = 'kepler155c/opus/master'\
local BASE = 'https://raw.githubusercontent.com/' .. GIT_REPO\
\
local function dourl(url, ...)\
  local env = setmetatable({ }, { __index = _G })\
  for k,v in pairs(getfenv(1)) do\
    env[k] = v \
  end\
\
  local h = http.get(url)\
  if h then\
    local fn, m = load(h.readAll(), url, nil, env)\
    h.close()\
    if fn then\
      return fn(...)\
    end\
  end\
  error('Failed to download ' .. url)\
end\
\
dourl(BASE .. '/sys/boot/multishell.boot', ...)",
    [ "sys/menus/default/o-a.lua" ] = "function termclear()\
    term.clear()\
    term.setCursorPos(1,1)\
end\
\
function buildmenu()\
    termclear()\
    print(\"1. Lattix(files)\")\
    print(\"2. Enchant3(Chat)\")\
    print(\"B. Back\")\
end\
function menu()\
buildmenu()\
option = io.read()\
print(option)\
if option==\"1\" then\
  shell.run(\"Lattix.lua\")\
elseif option==\"2\" then\
  shell.run(\"enchat3.lua\")\
end\
end\
menu()",
    [ "sys/startup/startup.lua" ] = "shell.setAlias(\"edit\",\"/metros/sys/apps/luaide\")\
shell.setAlias(\"laps\",\"/metros/sys/apps/laps\")\
shell.setAlias(\"files\",\"/metros/sys/apps/Lattix\")\
shell.setAlias(\"lattix\",\"/metros/sys/apps/Lattix\")\
shell.setAlias(\"metros\",\"/metros/sys/apps/.metros.lua\")\
shell.setDir(\"/metros/sys/menus/default\")\
shell.run(\"o.lua\")",
    [ "sys/menus/default/o-m.lua" ] = "function termclear()\
    term.clear()\
    term.setCursorPos(1,1)\
end\
print(\"Line 5 test\")\
function buildmenu()\
    termclear()\
    print(\"1. Reset Startup\")\
    print(\"2. Reset Device\")\
    print(\"3. Remove\")\
    print(\"4. Restart\")\
    print(\"5. Shutdown\")\
    print(\"B. Back\")\
end\
function menu()\
buildmenu()\
option = io.read()\
print(option)\
if option==\"1\" then\
  shell.run(\"metros\",\"startup\",\"reset\")\
elseif option ==\"2\" then\
  shell.run(\"metros\",\"reset\")\
elseif option==\"3\" then\
  shell.run(\"metros\",\"remove\")\
elseif option==\"4\" then\
  shell.run(\"reboot\")\
elseif option==\"5\" then\
  shell.run(\"shutdown\")\
elseif option==\"B\" then\
end\
end\
menu()",
    [ "sys/menus/default/o.lua" ] = "function termclear()\
    term.clear()\
    term.setCursorPos(1,1)\
end\
\
function buildmenu()\
    termclear()\
    print(\"1. Shell\")\
    print(\"2. Metros Menu\")\
    print(\"3. Apps\")\
end\
function menu()\
buildmenu()\
option = io.read()\
print(option)\
if option==\"1\"\
    then\
    shell.setDir(\"./\")\
    shell.run(\"fg\",\"shell\",\"\")\
    shell.setDir(\"metros/sys/menus/default\")\
elseif option==\"2\"\
    then\
    shell.run(\"o-m.lua\")\
elseif option==\"3\"\
    then\
    shell.run(\"o-a.lua\")\
end\
end\
while true do\
menu()\
end",
    [ "sys/apps/laps" ] = "local tArgs = {...}\
local cmd=tArgs[1]\
local app=tArgs[2]\
function install(app)\
 if app==\"todo\" \
 then\
    shell.run(\"pastebin\",\"get\", \"29h31MtZ\", \"todo\") \
 elseif app==\"DoorLock\"\
 then\
    shell.run(\"pastebin\", \"get\" , \"4QeAEiTM\", \"DoorLock\")\
 elseif app==\"cloud\"\
 then\
 	shell.run(\"wget\", \"https://cloud-catcher.squiddev.cc/cloud.lua\")\
 elseif app==\"progdor2\"\
 then\
    shell.run(\"wget\", \"https://raw.githubusercontent.com/LDDestroier/CC/master/progdor2.lua\")\
 elseif app==nil \
 then\
     print(\"Installs apps\")\
 else\
     print(\"App not found\")\
end\
end\
function remove(app)\
 shell.run(\"delete\",app)\
end\
\
\
\
\
\
--print(cmd,app)\
if cmd==\"install\" \
then\
    install(app)\
elseif cmd==\"remove\"\
then\
    remove(app)\
elseif cmd==\"list\"\
then\
    print(\"todo\")\
    print(\"DoorLock\")\
    print(\"cloud\")\
    print(\"progdor2\")\
elseif cmd==\"help\"\
   then\
    print(\"install [app name] - install an app\")\
	print(\"remove [app name] - remove an app\")\
	print(\"list - list all installable applications\")\
	print(\"help - show the help screen\")\
    print(\"update - update laps\")\
elseif cmd==nil\
then\
    shell.run(\"laps\",\"help\")\
elseif cmd==\"update\"\
then\
    print(\"Updating laps\")\
    os.sleep(2)\
    remove(\"laps\")\
    shell.run(\"pastebin\", \"get\" ,\"0aZZegfk\", \"laps\")\
    print(\"Updated laps\")\
end",
  },
}